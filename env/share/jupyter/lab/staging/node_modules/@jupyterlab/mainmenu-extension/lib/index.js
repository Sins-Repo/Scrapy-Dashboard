// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module mainmenu-extension
 */
import { each, find } from '@lumino/algorithm';
import { Widget } from '@lumino/widgets';
import { ILabShell, IRouter } from '@jupyterlab/application';
import { ICommandPalette, showDialog, Dialog } from '@jupyterlab/apputils';
import { PageConfig, URLExt } from '@jupyterlab/coreutils';
import { IMainMenu, MainMenu } from '@jupyterlab/mainmenu';
import { ServerConnection } from '@jupyterlab/services';
import { ITranslator } from '@jupyterlab/translation';
/**
 * A namespace for command IDs of semantic extension points.
 */
export var CommandIDs;
(function (CommandIDs) {
    CommandIDs.openEdit = 'editmenu:open';
    CommandIDs.undo = 'editmenu:undo';
    CommandIDs.redo = 'editmenu:redo';
    CommandIDs.clearCurrent = 'editmenu:clear-current';
    CommandIDs.clearAll = 'editmenu:clear-all';
    CommandIDs.find = 'editmenu:find';
    CommandIDs.goToLine = 'editmenu:go-to-line';
    CommandIDs.openFile = 'filemenu:open';
    CommandIDs.closeAndCleanup = 'filemenu:close-and-cleanup';
    CommandIDs.createConsole = 'filemenu:create-console';
    CommandIDs.shutdown = 'filemenu:shutdown';
    CommandIDs.logout = 'filemenu:logout';
    CommandIDs.openKernel = 'kernelmenu:open';
    CommandIDs.interruptKernel = 'kernelmenu:interrupt';
    CommandIDs.reconnectToKernel = 'kernelmenu:reconnect-to-kernel';
    CommandIDs.restartKernel = 'kernelmenu:restart';
    CommandIDs.restartKernelAndClear = 'kernelmenu:restart-and-clear';
    CommandIDs.restartAndRunToSelected = 'notebook:restart-and-run-to-selected';
    CommandIDs.changeKernel = 'kernelmenu:change';
    CommandIDs.shutdownKernel = 'kernelmenu:shutdown';
    CommandIDs.shutdownAllKernels = 'kernelmenu:shutdownAll';
    CommandIDs.openView = 'viewmenu:open';
    CommandIDs.wordWrap = 'viewmenu:word-wrap';
    CommandIDs.lineNumbering = 'viewmenu:line-numbering';
    CommandIDs.matchBrackets = 'viewmenu:match-brackets';
    CommandIDs.openRun = 'runmenu:open';
    CommandIDs.run = 'runmenu:run';
    CommandIDs.runAll = 'runmenu:run-all';
    CommandIDs.restartAndRunAll = 'runmenu:restart-and-run-all';
    CommandIDs.runAbove = 'runmenu:run-above';
    CommandIDs.runBelow = 'runmenu:run-below';
    CommandIDs.openTabs = 'tabsmenu:open';
    CommandIDs.activateById = 'tabsmenu:activate-by-id';
    CommandIDs.activatePreviouslyUsedTab = 'tabsmenu:activate-previously-used-tab';
    CommandIDs.openSettings = 'settingsmenu:open';
    CommandIDs.openHelp = 'helpmenu:open';
    CommandIDs.openFirst = 'mainmenu:open-first';
})(CommandIDs || (CommandIDs = {}));
/**
 * A service providing an interface to the main menu.
 */
const plugin = {
    id: '@jupyterlab/mainmenu-extension:plugin',
    requires: [IRouter, ITranslator],
    optional: [ICommandPalette, ILabShell],
    provides: IMainMenu,
    activate: (app, router, translator, palette, labShell) => {
        const { commands } = app;
        const trans = translator.load('jupyterlab');
        const menu = new MainMenu(commands);
        menu.id = 'jp-MainMenu';
        menu.addClass('jp-scrollbar-tiny');
        // Only add quit button if the back-end supports it by checking page config.
        const quitButton = PageConfig.getOption('quitButton').toLowerCase();
        menu.fileMenu.quitEntry = quitButton === 'true';
        // Create the application menus.
        createEditMenu(app, menu.editMenu, trans);
        createFileMenu(app, menu.fileMenu, router, trans);
        createKernelMenu(app, menu.kernelMenu, trans);
        createRunMenu(app, menu.runMenu, trans);
        createSettingsMenu(app, menu.settingsMenu, trans);
        createViewMenu(app, menu.viewMenu, trans);
        createHelpMenu(app, menu.helpMenu, trans);
        // Set the Tabs Title so it's visible also in other shells
        const tabsMenu = menu.tabsMenu;
        tabsMenu.menu.title.label = trans.__('Tabs');
        // The tabs menu relies on lab shell functionality.
        if (labShell) {
            createTabsMenu(app, tabsMenu, labShell, trans);
        }
        // Create commands to open the main application menus.
        const activateMenu = (item) => {
            menu.activeMenu = item;
            menu.openActiveMenu();
        };
        commands.addCommand(CommandIDs.openEdit, {
            label: trans.__('Open Edit Menu'),
            execute: () => activateMenu(menu.editMenu.menu)
        });
        commands.addCommand(CommandIDs.openFile, {
            label: trans.__('Open File Menu'),
            execute: () => activateMenu(menu.fileMenu.menu)
        });
        commands.addCommand(CommandIDs.openKernel, {
            label: trans.__('Open Kernel Menu'),
            execute: () => activateMenu(menu.kernelMenu.menu)
        });
        commands.addCommand(CommandIDs.openRun, {
            label: trans.__('Open Run Menu'),
            execute: () => activateMenu(menu.runMenu.menu)
        });
        commands.addCommand(CommandIDs.openView, {
            label: trans.__('Open View Menu'),
            execute: () => activateMenu(menu.viewMenu.menu)
        });
        commands.addCommand(CommandIDs.openSettings, {
            label: trans.__('Open Settings Menu'),
            execute: () => activateMenu(menu.settingsMenu.menu)
        });
        commands.addCommand(CommandIDs.openTabs, {
            label: trans.__('Open Tabs Menu'),
            execute: () => activateMenu(menu.tabsMenu.menu)
        });
        commands.addCommand(CommandIDs.openHelp, {
            label: trans.__('Open Help Menu'),
            execute: () => activateMenu(menu.helpMenu.menu)
        });
        commands.addCommand(CommandIDs.openFirst, {
            label: trans.__('Open First Menu'),
            execute: () => {
                menu.activeIndex = 0;
                menu.openActiveMenu();
            }
        });
        if (palette) {
            // Add some of the commands defined here to the command palette.
            if (menu.fileMenu.quitEntry) {
                palette.addItem({
                    command: CommandIDs.shutdown,
                    category: trans.__('Main Area')
                });
                palette.addItem({
                    command: CommandIDs.logout,
                    category: trans.__('Main Area')
                });
            }
            palette.addItem({
                command: CommandIDs.shutdownAllKernels,
                category: trans.__('Kernel Operations')
            });
            palette.addItem({
                command: CommandIDs.activatePreviouslyUsedTab,
                category: trans.__('Main Area')
            });
        }
        app.shell.add(menu, 'menu', { rank: 100 });
        return menu;
    }
};
/**
 * Create the basic `Edit` menu.
 */
export function createEditMenu(app, menu, trans) {
    const commands = menu.menu.commands;
    menu.menu.title.label = trans.__('Edit');
    // Add the undo/redo commands the the Edit menu.
    commands.addCommand(CommandIDs.undo, {
        label: trans.__('Undo'),
        isEnabled: Private.delegateEnabled(app, menu.undoers, 'undo'),
        execute: Private.delegateExecute(app, menu.undoers, 'undo')
    });
    commands.addCommand(CommandIDs.redo, {
        label: trans.__('Redo'),
        isEnabled: Private.delegateEnabled(app, menu.undoers, 'redo'),
        execute: Private.delegateExecute(app, menu.undoers, 'redo')
    });
    menu.addGroup([{ command: CommandIDs.undo }, { command: CommandIDs.redo }], 0);
    // Add the clear commands to the Edit menu.
    commands.addCommand(CommandIDs.clearCurrent, {
        label: () => {
            const enabled = Private.delegateEnabled(app, menu.clearers, 'clearCurrent')();
            let localizedLabel = trans.__('Clear');
            if (enabled) {
                localizedLabel = Private.delegateLabel(app, menu.clearers, 'clearCurrentLabel');
            }
            return localizedLabel;
        },
        isEnabled: Private.delegateEnabled(app, menu.clearers, 'clearCurrent'),
        execute: Private.delegateExecute(app, menu.clearers, 'clearCurrent')
    });
    commands.addCommand(CommandIDs.clearAll, {
        label: () => {
            const enabled = Private.delegateEnabled(app, menu.clearers, 'clearAll')();
            let localizedLabel = trans.__('Clear All');
            if (enabled) {
                localizedLabel = Private.delegateLabel(app, menu.clearers, 'clearAllLabel');
            }
            return localizedLabel;
        },
        isEnabled: Private.delegateEnabled(app, menu.clearers, 'clearAll'),
        execute: Private.delegateExecute(app, menu.clearers, 'clearAll')
    });
    menu.addGroup([{ command: CommandIDs.clearCurrent }, { command: CommandIDs.clearAll }], 10);
    commands.addCommand(CommandIDs.goToLine, {
        label: trans.__('Go to Lineâ€¦'),
        isEnabled: Private.delegateEnabled(app, menu.goToLiners, 'goToLine'),
        execute: Private.delegateExecute(app, menu.goToLiners, 'goToLine')
    });
    menu.addGroup([{ command: CommandIDs.goToLine }], 200);
}
/**
 * Create the basic `File` menu.
 */
export function createFileMenu(app, menu, router, trans) {
    const commands = menu.menu.commands;
    menu.menu.title.label = trans.__('File');
    menu.newMenu.menu.title.label = trans.__('New');
    // Add a delegator command for closing and cleaning up an activity.
    // This one is a bit different, in that we consider it enabled
    // even if it cannot find a delegate for the activity.
    // In that case, we instead call the application `close` command.
    commands.addCommand(CommandIDs.closeAndCleanup, {
        label: () => {
            const localizedLabel = Private.delegateLabel(app, menu.closeAndCleaners, 'closeAndCleanupLabel');
            return localizedLabel ? localizedLabel : trans.__('Close and Shutdown');
        },
        isEnabled: () => !!app.shell.currentWidget && !!app.shell.currentWidget.title.closable,
        execute: () => {
            // Check if we have a registered delegate. If so, call that.
            if (Private.delegateEnabled(app, menu.closeAndCleaners, 'closeAndCleanup')()) {
                return Private.delegateExecute(app, menu.closeAndCleaners, 'closeAndCleanup')();
            }
            // If we have no delegate, call the top-level application close.
            return app.commands.execute('application:close');
        }
    });
    // Add a delegator command for creating a console for an activity.
    commands.addCommand(CommandIDs.createConsole, {
        label: () => {
            const localizedLabel = Private.delegateLabel(app, menu.consoleCreators, 'createConsoleLabel');
            return localizedLabel
                ? localizedLabel
                : trans.__('New Console for Activity');
        },
        isEnabled: Private.delegateEnabled(app, menu.consoleCreators, 'createConsole'),
        execute: Private.delegateExecute(app, menu.consoleCreators, 'createConsole')
    });
    commands.addCommand(CommandIDs.shutdown, {
        label: trans.__('Shut Down'),
        caption: trans.__('Shut down JupyterLab'),
        execute: () => {
            return showDialog({
                title: trans.__('Shutdown confirmation'),
                body: trans.__('Please confirm you want to shut down JupyterLab.'),
                buttons: [
                    Dialog.cancelButton(),
                    Dialog.warnButton({ label: trans.__('Shut Down') })
                ]
            }).then(result => {
                if (result.button.accept) {
                    const setting = ServerConnection.makeSettings();
                    const apiURL = URLExt.join(setting.baseUrl, 'api/shutdown');
                    return ServerConnection.makeRequest(apiURL, { method: 'POST' }, setting)
                        .then(result => {
                        if (result.ok) {
                            // Close this window if the shutdown request has been successful
                            const body = document.createElement('div');
                            const p1 = document.createElement('p');
                            p1.textContent = trans.__('You have shut down the Jupyter server. You can now close this tab.');
                            const p2 = document.createElement('p');
                            p2.textContent = trans.__('To use JupyterLab again, you will need to relaunch it.');
                            body.appendChild(p1);
                            body.appendChild(p2);
                            void showDialog({
                                title: trans.__('Server stopped'),
                                body: new Widget({ node: body }),
                                buttons: []
                            });
                            window.close();
                        }
                        else {
                            throw new ServerConnection.ResponseError(result);
                        }
                    })
                        .catch(data => {
                        throw new ServerConnection.NetworkError(data);
                    });
                }
            });
        }
    });
    commands.addCommand(CommandIDs.logout, {
        label: trans.__('Log Out'),
        caption: trans.__('Log out of JupyterLab'),
        execute: () => {
            router.navigate('/logout', { hard: true });
        }
    });
    // Add the new group
    const newGroup = [
        { type: 'submenu', submenu: menu.newMenu.menu },
        { command: 'filebrowser:create-main-launcher' }
    ];
    const openGroup = [{ command: 'filebrowser:open-path' }];
    const newViewGroup = [
        { command: 'docmanager:clone' },
        { command: CommandIDs.createConsole }
    ].filter(item => !!item);
    // Add the close group
    const closeGroup = [
        'application:close',
        'filemenu:close-and-cleanup',
        'application:close-all'
    ].map(command => {
        return { command };
    });
    // Add save group.
    const saveGroup = [
        'docmanager:save',
        'docmanager:save-as',
        'docmanager:save-all'
    ].map(command => {
        return { command };
    });
    // Add the re group.
    const reGroup = [
        'docmanager:reload',
        'docmanager:restore-checkpoint',
        'docmanager:rename'
    ].map(command => {
        return { command };
    });
    // Add the quit group.
    const quitGroup = [
        { command: 'filemenu:logout' },
        { command: 'filemenu:shutdown' }
    ];
    const printGroup = [{ command: 'apputils:print' }];
    menu.addGroup(newGroup, 0);
    menu.addGroup(openGroup, 1);
    menu.addGroup(newViewGroup, 2);
    menu.addGroup(closeGroup, 3);
    menu.addGroup(saveGroup, 4);
    menu.addGroup(reGroup, 5);
    menu.addGroup(printGroup, 98);
    if (menu.quitEntry) {
        menu.addGroup(quitGroup, 99);
    }
}
/**
 * Create the basic `Kernel` menu.
 */
export function createKernelMenu(app, menu, trans) {
    const commands = menu.menu.commands;
    menu.menu.title.label = trans.__('Kernel');
    commands.addCommand(CommandIDs.interruptKernel, {
        label: trans.__('Interrupt Kernel'),
        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'interruptKernel'),
        execute: Private.delegateExecute(app, menu.kernelUsers, 'interruptKernel')
    });
    commands.addCommand(CommandIDs.reconnectToKernel, {
        label: trans.__('Reconnect to Kernel'),
        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'reconnectToKernel'),
        execute: Private.delegateExecute(app, menu.kernelUsers, 'reconnectToKernel')
    });
    commands.addCommand(CommandIDs.restartKernel, {
        label: trans.__('Restart Kernelâ€¦'),
        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'restartKernel'),
        execute: Private.delegateExecute(app, menu.kernelUsers, 'restartKernel')
    });
    commands.addCommand(CommandIDs.restartKernelAndClear, {
        label: () => {
            const enabled = Private.delegateEnabled(app, menu.kernelUsers, 'restartKernelAndClear')();
            let localizedLabel = trans.__('Restart Kernel and Clearâ€¦');
            if (enabled) {
                localizedLabel = Private.delegateLabel(app, menu.kernelUsers, 'restartKernelAndClearLabel');
            }
            return localizedLabel;
        },
        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'restartKernelAndClear'),
        execute: Private.delegateExecute(app, menu.kernelUsers, 'restartKernelAndClear')
    });
    commands.addCommand(CommandIDs.changeKernel, {
        label: trans.__('Change Kernelâ€¦'),
        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'changeKernel'),
        execute: Private.delegateExecute(app, menu.kernelUsers, 'changeKernel')
    });
    commands.addCommand(CommandIDs.shutdownKernel, {
        label: trans.__('Shut Down Kernel'),
        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'shutdownKernel'),
        execute: Private.delegateExecute(app, menu.kernelUsers, 'shutdownKernel')
    });
    commands.addCommand(CommandIDs.shutdownAllKernels, {
        label: trans.__('Shut Down All Kernelsâ€¦'),
        isEnabled: () => {
            return app.serviceManager.sessions.running().next() !== undefined;
        },
        execute: () => {
            return showDialog({
                title: trans.__('Shut Down All?'),
                body: trans.__('Shut down all kernels?'),
                buttons: [
                    Dialog.cancelButton({ label: trans.__('Dismiss') }),
                    Dialog.warnButton({ label: trans.__('Shut Down All') })
                ]
            }).then(result => {
                if (result.button.accept) {
                    return app.serviceManager.sessions.shutdownAll();
                }
            });
        }
    });
    const restartGroup = [
        CommandIDs.restartKernel,
        CommandIDs.restartKernelAndClear,
        CommandIDs.restartAndRunToSelected,
        CommandIDs.restartAndRunAll
    ].map(command => {
        return { command };
    });
    menu.addGroup([{ command: CommandIDs.interruptKernel }], 0);
    menu.addGroup(restartGroup, 1);
    menu.addGroup([{ command: CommandIDs.reconnectToKernel }], 1.5);
    menu.addGroup([
        { command: CommandIDs.shutdownKernel },
        { command: CommandIDs.shutdownAllKernels }
    ], 2);
    menu.addGroup([{ command: CommandIDs.changeKernel }], 3);
}
/**
 * Create the basic `View` menu.
 */
export function createViewMenu(app, menu, trans) {
    const commands = menu.menu.commands;
    menu.menu.title.label = trans.__('View');
    commands.addCommand(CommandIDs.lineNumbering, {
        label: trans.__('Show Line Numbers'),
        isEnabled: Private.delegateEnabled(app, menu.editorViewers, 'toggleLineNumbers'),
        isToggled: Private.delegateToggled(app, menu.editorViewers, 'lineNumbersToggled'),
        execute: Private.delegateExecute(app, menu.editorViewers, 'toggleLineNumbers')
    });
    commands.addCommand(CommandIDs.matchBrackets, {
        label: trans.__('Match Brackets'),
        isEnabled: Private.delegateEnabled(app, menu.editorViewers, 'toggleMatchBrackets'),
        isToggled: Private.delegateToggled(app, menu.editorViewers, 'matchBracketsToggled'),
        execute: Private.delegateExecute(app, menu.editorViewers, 'toggleMatchBrackets')
    });
    commands.addCommand(CommandIDs.wordWrap, {
        label: trans.__('Wrap Words'),
        isEnabled: Private.delegateEnabled(app, menu.editorViewers, 'toggleWordWrap'),
        isToggled: Private.delegateToggled(app, menu.editorViewers, 'wordWrapToggled'),
        execute: Private.delegateExecute(app, menu.editorViewers, 'toggleWordWrap')
    });
    menu.addGroup([{ command: 'apputils:activate-command-palette' }], 0);
    menu.addGroup([
        { command: 'application:toggle-mode' },
        { command: 'application:toggle-presentation-mode' }
    ], 1);
    menu.addGroup([
        { command: 'application:toggle-left-area' },
        { command: 'application:toggle-right-area' }
    ], 2);
    const editorViewerGroup = [
        CommandIDs.lineNumbering,
        CommandIDs.matchBrackets,
        CommandIDs.wordWrap
    ].map(command => {
        return { command };
    });
    menu.addGroup(editorViewerGroup, 10);
}
/**
 * Create the basic `Run` menu.
 */
export function createRunMenu(app, menu, trans) {
    const commands = menu.menu.commands;
    menu.menu.title.label = trans.__('Run');
    commands.addCommand(CommandIDs.run, {
        label: () => {
            const localizedLabel = Private.delegateLabel(app, menu.codeRunners, 'runLabel');
            const enabled = Private.delegateEnabled(app, menu.codeRunners, 'run')();
            return enabled ? localizedLabel : trans.__('Run Selected');
        },
        isEnabled: Private.delegateEnabled(app, menu.codeRunners, 'run'),
        execute: Private.delegateExecute(app, menu.codeRunners, 'run')
    });
    commands.addCommand(CommandIDs.runAll, {
        label: () => {
            let localizedLabel = trans.__('Run All');
            const enabled = Private.delegateEnabled(app, menu.codeRunners, 'runAll')();
            if (enabled) {
                localizedLabel = Private.delegateLabel(app, menu.codeRunners, 'runAllLabel');
            }
            return localizedLabel;
        },
        isEnabled: Private.delegateEnabled(app, menu.codeRunners, 'runAll'),
        execute: Private.delegateExecute(app, menu.codeRunners, 'runAll')
    });
    commands.addCommand(CommandIDs.restartAndRunAll, {
        label: () => {
            let localizedLabel = trans.__('Restart Kernel and Run All');
            const enabled = Private.delegateEnabled(app, menu.codeRunners, 'restartAndRunAll')();
            if (enabled) {
                localizedLabel = Private.delegateLabel(app, menu.codeRunners, 'restartAndRunAllLabel');
            }
            return localizedLabel;
        },
        isEnabled: Private.delegateEnabled(app, menu.codeRunners, 'restartAndRunAll'),
        execute: Private.delegateExecute(app, menu.codeRunners, 'restartAndRunAll')
    });
    const runAllGroup = [CommandIDs.runAll, CommandIDs.restartAndRunAll].map(command => {
        return { command };
    });
    menu.addGroup([{ command: CommandIDs.run }], 0);
    menu.addGroup(runAllGroup, 999);
}
/**
 * Create the basic `Settings` menu.
 */
export function createSettingsMenu(_, menu, trans) {
    menu.menu.title.label = trans.__('Settings');
    menu.addGroup([{ command: 'settingeditor:open' }], 1000);
}
/**
 * Create the basic `Tabs` menu.
 */
export function createTabsMenu(app, menu, labShell, trans) {
    const commands = app.commands;
    // Add commands for cycling the active tabs.
    menu.addGroup([
        { command: 'application:activate-next-tab' },
        { command: 'application:activate-previous-tab' },
        { command: 'application:activate-next-tab-bar' },
        { command: 'application:activate-previous-tab-bar' },
        { command: CommandIDs.activatePreviouslyUsedTab }
    ], 0);
    // A list of the active tabs in the main area.
    const tabGroup = [];
    // A disposable for getting rid of the out-of-date tabs list.
    let disposable;
    // Command to activate a widget by id.
    commands.addCommand(CommandIDs.activateById, {
        label: args => {
            const id = args['id'] || '';
            const widget = find(app.shell.widgets('main'), w => w.id === id);
            return (widget && widget.title.label) || '';
        },
        isToggled: args => {
            const id = args['id'] || '';
            return !!app.shell.currentWidget && app.shell.currentWidget.id === id;
        },
        execute: args => app.shell.activateById(args['id'] || '')
    });
    let previousId = '';
    // Command to toggle between the current
    // tab and the last modified tab.
    commands.addCommand(CommandIDs.activatePreviouslyUsedTab, {
        label: trans.__('Activate Previously Used Tab'),
        isEnabled: () => !!previousId,
        execute: () => commands.execute(CommandIDs.activateById, { id: previousId })
    });
    if (labShell) {
        void app.restored.then(() => {
            // Iterate over the current widgets in the
            // main area, and add them to the tab group
            // of the menu.
            const populateTabs = () => {
                // remove the previous tab list
                if (disposable && !disposable.isDisposed) {
                    disposable.dispose();
                }
                tabGroup.length = 0;
                let isPreviouslyUsedTabAttached = false;
                each(app.shell.widgets('main'), widget => {
                    if (widget.id === previousId) {
                        isPreviouslyUsedTabAttached = true;
                    }
                    tabGroup.push({
                        command: CommandIDs.activateById,
                        args: { id: widget.id }
                    });
                });
                disposable = menu.addGroup(tabGroup, 1);
                previousId = isPreviouslyUsedTabAttached ? previousId : '';
            };
            populateTabs();
            labShell.layoutModified.connect(() => {
                populateTabs();
            });
            // Update the ID of the previous active tab if a new tab is selected.
            labShell.currentChanged.connect((_, args) => {
                const widget = args.oldValue;
                if (!widget) {
                    return;
                }
                previousId = widget.id;
            });
        });
    }
}
/**
 * Create the basic `Help` menu.
 */
export function createHelpMenu(app, menu, trans) {
    menu.menu.title.label = trans.__('Help');
}
export default plugin;
/**
 * A namespace for Private data.
 */
var Private;
(function (Private) {
    /**
     * Return the first value of the iterable that satisfies the predicate
     * function.
     */
    function find(it, predicate) {
        for (const value of it) {
            if (predicate(value)) {
                return value;
            }
        }
        return undefined;
    }
    /**
     * A utility function that delegates a portion of a label to an IMenuExtender.
     */
    function delegateLabel(app, s, label) {
        const widget = app.shell.currentWidget;
        const extender = widget
            ? find(s, value => value.tracker.has(widget))
            : undefined;
        if (!extender) {
            return '';
        }
        else {
            const count = extender.tracker.size;
            // Coerce the result to be a string. When Typedoc is updated to use
            // Typescript 2.8, we can possibly use conditional types to get Typescript
            // to recognize this is a string.
            return extender[label](count);
        }
    }
    Private.delegateLabel = delegateLabel;
    /**
     * A utility function that delegates command execution
     * to an IMenuExtender.
     */
    function delegateExecute(app, s, executor) {
        return () => {
            const widget = app.shell.currentWidget;
            const extender = widget
                ? find(s, value => value.tracker.has(widget))
                : undefined;
            if (!extender) {
                return Promise.resolve(void 0);
            }
            // Coerce the result to be a function. When Typedoc is updated to use
            // Typescript 2.8, we can possibly use conditional types to get Typescript
            // to recognize this is a function.
            const f = extender[executor];
            return f(widget);
        };
    }
    Private.delegateExecute = delegateExecute;
    /**
     * A utility function that delegates whether a command is enabled
     * to an IMenuExtender.
     */
    function delegateEnabled(app, s, executor) {
        return () => {
            const widget = app.shell.currentWidget;
            const extender = widget
                ? find(s, value => value.tracker.has(widget))
                : undefined;
            return (!!extender &&
                !!extender[executor] &&
                (extender.isEnabled && widget ? extender.isEnabled(widget) : true));
        };
    }
    Private.delegateEnabled = delegateEnabled;
    /**
     * A utility function that delegates whether a command is toggled
     * for an IMenuExtender.
     */
    function delegateToggled(app, s, toggled) {
        return () => {
            const widget = app.shell.currentWidget;
            const extender = widget
                ? find(s, value => value.tracker.has(widget))
                : undefined;
            // Coerce extender[toggled] to be a function. When Typedoc is updated to use
            // Typescript 2.8, we can possibly use conditional types to get Typescript
            // to recognize this is a function.
            return (!!extender &&
                !!extender[toggled] &&
                !!widget &&
                !!extender[toggled](widget));
        };
    }
    Private.delegateToggled = delegateToggled;
})(Private || (Private = {}));
//# sourceMappingURL=index.js.map