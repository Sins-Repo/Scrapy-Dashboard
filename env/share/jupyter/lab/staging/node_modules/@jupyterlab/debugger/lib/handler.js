// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { ToolbarButton } from '@jupyterlab/apputils';
import { nullTranslator } from '@jupyterlab/translation';
import { bugIcon, Switch } from '@jupyterlab/ui-components';
import { Debugger } from './debugger';
import { ConsoleHandler } from './handlers/console';
import { FileHandler } from './handlers/file';
import { NotebookHandler } from './handlers/notebook';
/**
 * Add a bug icon to the widget toolbar to enable and disable debugging.
 *
 * @param widget The widget to add the debug toolbar button to.
 * @param onClick The callback when the toolbar button is clicked.
 */
function updateIconButton(widget, onClick, translator) {
    translator = translator || nullTranslator;
    const trans = translator.load('jupyterlab');
    const icon = new ToolbarButton({
        className: 'jp-DebuggerBugButton',
        icon: bugIcon,
        tooltip: trans.__('Enable / Disable Debugger'),
        onClick
    });
    widget.toolbar.addItem('debugger-icon', icon);
    return icon;
}
/**
 * Add a toggle button to the widget toolbar to enable and disable debugging.
 *
 * @param widget The widget to add the debug toolbar button to.
 * @param onClick The callback when the toolbar button is clicked.
 */
function updateToggleButton(widget, sessionStarted, onClick, translator) {
    translator = translator || nullTranslator;
    const trans = translator.load('jupyterlab');
    const button = new Switch();
    button.id = 'jp-debugger';
    button.value = sessionStarted;
    button.caption = trans.__('Enable / Disable Debugger');
    button.handleEvent = (event) => {
        event.preventDefault();
        switch (event.type) {
            case 'click':
                onClick();
                break;
            default:
                break;
        }
    };
    widget.toolbar.addItem('debugger-button', button);
    return button;
}
/**
 * A handler for debugging a widget.
 */
export class DebuggerHandler {
    /**
     * Instantiate a new DebuggerHandler.
     *
     * @param options The instantiation options for a DebuggerHandler.
     */
    constructor(options) {
        this._handlers = {};
        this._contextKernelChangedHandlers = {};
        this._kernelChangedHandlers = {};
        this._statusChangedHandlers = {};
        this._iconButtons = {};
        this._toggleButtons = {};
        this._type = options.type;
        this._shell = options.shell;
        this._service = options.service;
    }
    /**
     * Update a debug handler for the given widget, and
     * handle kernel changed events.
     *
     * @param widget The widget to update.
     * @param connection The session connection.
     */
    async update(widget, connection) {
        if (!connection) {
            delete this._kernelChangedHandlers[widget.id];
            delete this._statusChangedHandlers[widget.id];
            return this._update(widget, connection);
        }
        const kernelChanged = () => {
            void this._update(widget, connection);
        };
        const kernelChangedHandler = this._kernelChangedHandlers[widget.id];
        if (kernelChangedHandler) {
            connection.kernelChanged.disconnect(kernelChangedHandler);
        }
        this._kernelChangedHandlers[widget.id] = kernelChanged;
        connection.kernelChanged.connect(kernelChanged);
        const statusChanged = (_, status) => {
            // FIXME-TRANS: Localizable?
            if (status.endsWith('restarting')) {
                void this._update(widget, connection);
            }
        };
        const statusChangedHandler = this._statusChangedHandlers[widget.id];
        if (statusChangedHandler) {
            connection.statusChanged.disconnect(statusChangedHandler);
        }
        connection.statusChanged.connect(statusChanged);
        this._statusChangedHandlers[widget.id] = statusChanged;
        return this._update(widget, connection);
    }
    /**
     * Update a debug handler for the given widget, and
     * handle connection kernel changed events.
     *
     * @param widget The widget to update.
     * @param sessionContext The session context.
     */
    async updateContext(widget, sessionContext) {
        const connectionChanged = () => {
            const { session: connection } = sessionContext;
            void this.update(widget, connection);
        };
        const contextKernelChangedHandlers = this._contextKernelChangedHandlers[widget.id];
        if (contextKernelChangedHandlers) {
            sessionContext.kernelChanged.disconnect(contextKernelChangedHandlers);
        }
        this._contextKernelChangedHandlers[widget.id] = connectionChanged;
        sessionContext.kernelChanged.connect(connectionChanged);
        return this.update(widget, sessionContext.session);
    }
    /**
     * Update a debug handler for the given widget.
     *
     * @param widget The widget to update.
     * @param connection The session connection.
     */
    async _update(widget, connection) {
        var _a, _b;
        if (!this._service.model || !connection) {
            return;
        }
        const hasFocus = () => {
            return this._shell.currentWidget === widget;
        };
        const updateAttribute = () => {
            if (!this._handlers[widget.id]) {
                widget.node.removeAttribute('data-jp-debugger');
                return;
            }
            widget.node.setAttribute('data-jp-debugger', 'true');
        };
        const createHandler = () => {
            if (this._handlers[widget.id]) {
                return;
            }
            switch (this._type) {
                case 'notebook':
                    this._handlers[widget.id] = new NotebookHandler({
                        debuggerService: this._service,
                        widget: widget
                    });
                    break;
                case 'console':
                    this._handlers[widget.id] = new ConsoleHandler({
                        debuggerService: this._service,
                        widget: widget
                    });
                    break;
                case 'file':
                    this._handlers[widget.id] = new FileHandler({
                        debuggerService: this._service,
                        widget: widget
                    });
                    break;
                default:
                    throw Error(`No handler for the type ${this._type}`);
            }
            updateAttribute();
        };
        const removeHandlers = () => {
            var _a, _b, _c, _d;
            const handler = this._handlers[widget.id];
            if (!handler) {
                return;
            }
            handler.dispose();
            delete this._handlers[widget.id];
            delete this._kernelChangedHandlers[widget.id];
            delete this._statusChangedHandlers[widget.id];
            delete this._contextKernelChangedHandlers[widget.id];
            // Clear the model if the handler being removed corresponds
            // to the current active debug session, or if the connection
            // does not have a kernel.
            if (((_b = (_a = this._service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.path) === (connection === null || connection === void 0 ? void 0 : connection.path) ||
                !((_d = (_c = this._service.session) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.kernel)) {
                const model = this._service.model;
                model.clear();
            }
            updateAttribute();
        };
        const addToolbarButton = () => {
            if (!this._iconButtons[widget.id]) {
                this._iconButtons[widget.id] = updateIconButton(widget, toggleDebugging);
            }
            if (!this._toggleButtons[widget.id]) {
                this._toggleButtons[widget.id] = updateToggleButton(widget, this._service.isStarted, toggleDebugging);
            }
            this._toggleButtons[widget.id].value = this._service.isStarted;
        };
        const removeToolbarButton = () => {
            if (!this._iconButtons[widget.id]) {
                return;
            }
            else {
                this._iconButtons[widget.id].dispose();
                delete this._iconButtons[widget.id];
            }
            if (!this._toggleButtons[widget.id]) {
                return;
            }
            else {
                this._toggleButtons[widget.id].dispose();
                delete this._toggleButtons[widget.id];
            }
        };
        const toggleDebugging = async () => {
            var _a;
            // bail if the widget doesn't have focus
            if (!hasFocus()) {
                return;
            }
            if (this._service.isStarted &&
                ((_a = this._previousConnection) === null || _a === void 0 ? void 0 : _a.id) === (connection === null || connection === void 0 ? void 0 : connection.id)) {
                if (this._toggleButtons[widget.id]) {
                    this._toggleButtons[widget.id].value = false;
                }
                this._service.session.connection = connection;
                await this._service.stop();
                removeHandlers();
            }
            else {
                if (this._toggleButtons[widget.id]) {
                    this._toggleButtons[widget.id].value = true;
                }
                this._service.session.connection = connection;
                this._previousConnection = connection;
                await this._service.restoreState(true);
                createHandler();
            }
        };
        const debuggingEnabled = await this._service.isAvailable(connection);
        if (!debuggingEnabled) {
            removeHandlers();
            removeToolbarButton();
            return;
        }
        // update the active debug session
        if (!this._service.session) {
            this._service.session = new Debugger.Session({ connection });
        }
        else {
            this._previousConnection = ((_a = this._service.session.connection) === null || _a === void 0 ? void 0 : _a.kernel) ? this._service.session.connection
                : null;
            this._service.session.connection = connection;
        }
        await this._service.restoreState(false);
        addToolbarButton();
        // check the state of the debug session
        if (!this._service.isStarted) {
            removeHandlers();
            this._service.session.connection = (_b = this._previousConnection) !== null && _b !== void 0 ? _b : connection;
            await this._service.restoreState(false);
            return;
        }
        // if the debugger is started but there is no handler, create a new one
        createHandler();
        this._previousConnection = connection;
        // listen to the disposed signals
        widget.disposed.connect(removeHandlers);
    }
}
//# sourceMappingURL=handler.js.map