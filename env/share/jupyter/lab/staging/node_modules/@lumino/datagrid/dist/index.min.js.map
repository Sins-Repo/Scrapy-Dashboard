{"version":3,"sources":["../src/basicmousehandler.ts","../src/basickeyhandler.ts","../../../node_modules/tslib/tslib.es6.js","../src/selectionmodel.ts","../src/basicselectionmodel.ts","../src/cellrenderer.ts","../src/notification.ts","../src/celleditor.ts","../src/datamodel.ts","../src/graphicscontext.ts","../src/textrenderer.ts","../src/sectionlist.ts","../src/renderermap.ts","../src/celleditorcontroller.ts","../src/datagrid.ts","../src/jsonmodel.ts"],"names":["Private","BasicKeyHandler","this","_disposed","Object","defineProperty","prototype","dispose","onKeyDown","grid","event","editable","selectionModel","cursorRow","cursorColumn","input","String","fromCharCode","keyCode","test","cell","row","column","editorController","edit","getKeyboardLayout","keyForKeydownEvent","stopPropagation","preventDefault","onArrowLeft","onArrowRight","onArrowUp","onArrowDown","onPageUp","onPageDown","onEscape","onDelete","onKeyC","moveCursor","shiftKey","scrollToCursor","model","shift","accel","Platform","accelKey","mode","selectionMode","scrollTo","scrollY","r1","r2","c1","c2","cr","cc","clear","r","c","cs","currentSelection","select","scrollToColumn","scrollByStep","maxScrollX","Infinity","scrollX","scrollToRow","maxScrollY","n","Math","floor","pageHeight","defaultSizes","rowHeight","scrollByPage","isEmpty","dataModel","maxRow","rowCount","maxColumn","columnCount","it","selections","s","undefined","next","sr1","max","min","sc1","sr2","sc2","setData","copyToClipboard","BasicMouseHandler","release","_pressData","type","timeout","override","onMouseHover","hit","hitTest","clientX","clientY","handle","resizeHandleForHitTest","cursor","cursorForHandle","viewport","node","style","onMouseLeave","onMouseDown","region","model_1","r1_1","c1_1","r2_1","c2_1","cursorRow_1","cursorColumn_1","clear_1","override_1","Drag","overrideCursor","localX","localY","rgn","index","size","rowSize","override_3","columnSize","override_2","onMouseMove","data","_a","mapToLocal","lx","ly","hw","headerWidth","hh","headerHeight","vpw","viewportWidth","vph","viewportHeight","sx","sy","msx","msy","computeTimeout","setTimeout","autoselect","_b","mapToVirtual","vx","vy","bodyWidth","bodyHeight","rowAt","columnAt","dx","resizeColumn","dy","resizeRow","onMouseUp","onMouseDoubleClick","onContextMenu","onWheel","deltaX","deltaY","deltaMode","ds","columnWidth","pageWidth","scrollBy","cursorMap","result","lw","x","lh","y","tw","width","th","height","scrollToCell","delta","abs","top","left","right","bottom","none","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","__assign","assign","t","i","arguments","length","call","apply","SelectionModel","options","_changed","Signal","_selectionMode","changed","connect","onDataModelChanged","value","isRowSelected","some","containsRow","isColumnSelected","containsColumn","isCellSelected","containsCell","sender","args","emitChanged","emit","selection","BasicSelectionModel","_this","_super","_cursorRow","_cursorColumn","_cursorRectIndex","_selections","moveCursorWithinSelections","direction","firstSelection","cursorRect","dr","dc","newRow","newColumn","moveToNextRect","moveToPreviousRect","iter","pop","push","lr","lc","j","CellRenderer","resolveOption","option","config","Notification","createNode","_message","addClass","setFlag","Widget","Flag","DisallowLayout","_target","target","message","_placement","placement","attach","document","body","close","handleEvent","_evtMouseDown","update","getElementsByClassName","onBeforeAttach","msg","addEventListener","onAfterDetach","removeEventListener","onUpdateRequest","targetRect","getBoundingClientRect","alignItems","justifyContent","messageNode","innerHTML","button","createElement","container","className","appendChild","PassInputValidator","validate","valid","TextInputValidator","minLength","Number","NaN","maxLength","pattern","isNaN","IntegerInputValidator","NumberInputValidator","CellEditor","inputChanged","validityNotification","_validInput","_gridWheelEventHandler","_closeValidityNotification","removeChild","viewportOccluder","onCommit","onCancel","validator","createValidatorBasedOnType","updatePosition","_addContainer","startEditing","cancel","getInput","error","console","log","setValidity","editorContainer","classList","remove","add","show","metadata","format","RegExp","constraint","minimum","maximum","getCellInfo","columnX","columnOffset","rowY","rowOffset","cellInfo","position","visibility","commit","cursorMovement","pointerEvents","InputCellEditor","_onKeyDown","_onBlur","_onInput","isDisposed","_unbindEvents","createWidget","deserialize","focus","bindEvents","toString","spellcheck","inputType","TextCellEditor","NumberCellEditor","step","trim","floatValue","parseFloat","Error","IntegerCellEditor","intValue","parseInt","DateCellEditor","_createWidget","_input","_deserialize","_bindEvents","BooleanCellEditor","checked","OptionCellEditor","_isMultiSelect","_select","multiple","values","item","selected","indexOf","selectedOptions","editorContainerRect","maxHeight","isArray","_i","value_1","items","enum","items_1","text","bind","DynamicOptionCellEditor","list","id","valueSet","Set","forEach","setAttribute","DataModel","emptyMetadata","MutableDataModel","freeze","TextRenderer","GraphicsContext","context","_context","_state","State","restore","fillStyle","strokeStyle","font","textAlign","textBaseline","lineCap","lineDashOffset","lineJoin","lineWidth","miterLimit","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","imageSmoothingEnabled","globalAlpha","globalCompositeOperation","getLineDash","setLineDash","segments","rotate","angle","scale","transform","m11","m12","m21","m22","translate","setTransform","save","beginPath","closePath","isPointInPath","fillRule","arc","radius","startAngle","endAngle","anticlockwise","arcTo","x1","y1","x2","y2","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","ellipse","radiusX","radiusY","rotation","lineTo","moveTo","quadraticCurveTo","cpx","cpy","rect","w","h","clip","fill","stroke","clearRect","fillRect","fillText","maxWidth","strokeRect","strokeText","measureText","createLinearGradient","x0","y0","createRadialGradient","r0","createPattern","image","repetition","createImageData","getImageData","sw","sh","putImageData","drawImage","drawFocusIfNeeded","element","pi","pool","state","other","textColor","backgroundColor","verticalAlignment","horizontalAlignment","formatGeneric","elideDirection","paint","gc","drawBackground","drawText","color","vAlign","hAlign","boxHeight","textX","textY","boxWidth","textHeight","measureFontHeight","textWidth","substring","missing","formatFixed","digits","toFixed","formatPrecision","toPrecision","formatExponential","toExponential","formatIntlNumber","nft","Intl","NumberFormat","locales","formatDate","Date","toDateString","formatTime","toTimeString","formatISODateTime","toISOString","formatUTCDateTime","toUTCString","formatIntlDateTime","dtf","DateTimeFormat","fontHeightCache","fontMeasurementGC","normFont","fontMeasurementNode","offsetHeight","canvas","textContent","getContext","RendererMap","fallback","_values","_fallback","get","renderer","err","SectionList","_count","_length","_sections","_minimumSize","minimumSize","_defaultSize","defaultSize","prev","curr","count","offset","clampSize","ArrayExt","lowerBound","offsetCmp","section","span","offsetOf","indexCmp","extentOf","sizeOf","resize","insert","removed","splice","k","move","destination","i1","k1","i2","k2","upperBound","pivot","count1","count2","span1","span2","k3","reset","CellEditorController","_editor","_cell","_typeBasedOverrides","Map","_metadataBasedOverrides","setEditor","identifier","editor","set","key","_metadataIdentifierToKey","_onCommit","_onCancel","_getEditor","response","_getDataTypeKey","_objectToKey","object","str","_metadataMatchesIdentifier","identifierValue","metadataValue","_getMetadataBasedEditor","editorMatched","dtKey","has","DataGrid","_scrollX","_scrollY","_viewportWidth","_viewportHeight","_mousedown","_keyHandler","_mouseHandler","_vScrollBarMinWidth","_hScrollBarMinHeight","_dpiRatio","ceil","window","devicePixelRatio","_dataModel","_selectionModel","_editingEnabled","_style","defaultStyle","_stretchLastRow","stretchLastRow","_stretchLastColumn","stretchLastColumn","_headerVisibility","headerVisibility","_cellRenderers","cellRenderers","_copyConfig","copyConfig","defaultCopyConfig","_onRenderersChanged","minimumSizes","_rowSections","_columnSections","_rowHeaderSections","rowHeaderWidth","_columnHeaderSections","columnHeaderHeight","_canvas","createCanvas","_buffer","_overlay","_canvasGC","_bufferGC","_overlayGC","_viewport","tabIndex","outline","_vScrollBar","ScrollBar","orientation","_hScrollBar","_scrollCorner","_editorController","MessageLoop","installMessageHook","hide","thumbMoved","_onThumbMoved","pageRequested","_onPageRequested","stepRequested","_onStepRequested","GridLayout","setCellConfig","layout","rowSpacing","columnSpacing","fitPolicy","setRowStretch","setColumnStretch","addWidget","_releaseMouse","disconnect","_onDataModelChanged","_syncViewport","_onSelectionsChanged","repaintOverlay","repaintContent","controller","enabled","nr","vy1","vy2","nc","vx1","vx2","currentSel","dir","rows","columns","postMessage","ScrollRequest","bh","ph","bw","pw","RowResizeRequest","ColumnResizeRequest","resetRows","resetColumns","row_1","column_1","row_2","column_2","row_3","column_3","row_4","column_4","toArray","alert","br","bc","_c","rhc","chr","separator","headers","warningThreshold","colCount","cellCount","confirm","cells","map","join","ClipboardExt","copyText","processMessage","vsbLimits","ElementExt","sizeLimits","hsbLimits","minWidth","minHeight","messageHook","handler","_processViewportMessage","activate","_evtKeyDown","_evtMouseMove","_evtMouseUp","_evtMouseDoubleClick","_evtMouseLeave","_evtContextMenu","_evtWheel","_refreshDPI","onActivateRequest","onBeforeShow","onResize","_syncScrollState","PaintRequest","_repaintRegion","OverlayPaintRequest","_resizeCanvasIfNeeded","maxW","maxH","curW","curH","expW","expH","needBlit","hasVScroll","isHidden","hasHScroll","vsw","hsh","apw","aph","needVScroll","needHScroll","setHidden","sendMessage","Msg","FitRequest","page","_scrollTo","_onViewportResize","_onViewportScrollRequest","_onViewportPaintRequest","_onViewportOverlayPaintRequest","_onViewportRowResizeRequest","_onViewportColumnResizeRequest","isVisible","offsetWidth","round","oldWidth","oldHeight","paintContent","_paintOverlay","bx","by","xMax","yMax","rs","rhs","chs","_resizeRow","_resizeColumnHeader","_resizeColumn","_resizeRowHeader","_onRowsInserted","_onColumnsInserted","_onRowsRemoved","_onColumnsRemoved","_onRowsMoved","_onColumnsMoved","_onCellsChanged","_onModelReset","rowSpan","columnSpan","nrh","nch","drh","dch","dpiRatio","oldSize","newSize","vw","vh","pos","_blitContent","contentX","contentY","contentWidth","contentHeight","dxArea","dyArea","y_5","x_6","source","rx","ry","rw","rh","_drawVoidRegion","_drawBodyRegion","_drawRowHeaderRegion","_drawColumnHeaderRegion","drawCornerHeaderRegion","_drawBodySelections","_drawRowHeaderSelections","_drawColumnHeaderSelections","_drawCursor","_drawShadows","voidColor","contentW","contentH","rowSizes","columnSizes","dh","dw","xMin","yMin","_drawBackground","_drawRowBackground","rowBackgroundColor","_drawColumnBackground","columnBackgroundColor","_drawCells","_drawHorizontalGridLines","horizontalGridLineColor","gridLineColor","_drawVerticalGridLines","verticalGridLineColor","headerBackgroundColor","headerHorizontalGridLineColor","headerGridLineColor","headerVerticalGridLineColor","colorFn","n_1","selectionFillColor","selectionBorderColor","tmp","headerSelectionFillColor","headerSelectionBorderColor","maxCol","cursorFillColor","cursorBorderColor","shadow","scrollShadow","sxMax","syMax","grad","addColorStop","color1","color2","color3","copyFormatGeneric","ConflatableMessage","SectionResizeRequest","_region","_r1","_c1","_r2","_c2","conflate","_index","_size","JSONModel","split","splitFields","schema","_data","_bodyFields","bodyFields","_headerFields","headerFields","_missingValues","createMissingMap","field","name","title","primaryKeys","primaryKey","fields","missingValues"],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\nimport {\n  Platform\n} from '@lumino/domutils';\n\nimport {\n  Drag\n} from '@lumino/dragdrop';\n\nimport {\n  DataGrid\n} from './datagrid';\n\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  CellEditor\n} from './celleditor';\n\n/**\n * A basic implementation of a data grid mouse handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport\nclass BasicMouseHandler implements DataGrid.IMouseHandler {\n  /**\n   * Dispose of the resources held by the mouse handler.\n   */\n  dispose(): void {\n    // Bail early if the handler is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Release any held resources.\n    this.release();\n\n    // Mark the handler as disposed.\n    this._disposed = true;\n  }\n\n  /**\n   * Whether the mouse handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Release the resources held by the handler.\n   */\n  release(): void {\n    // Bail early if the is no press data.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the autoselect timeout.\n    if (this._pressData.type === 'select') {\n      this._pressData.timeout = -1;\n    }\n\n    // Clear the press data.\n    this._pressData.override.dispose();\n    this._pressData = null;\n  }\n\n  /**\n   * Handle the mouse hover event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseHover(grid: DataGrid, event: MouseEvent): void {\n    // Hit test the grid.\n    let hit = grid.hitTest(event.clientX, event.clientY);\n\n    // Get the resize handle for the hit test.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Update the viewport cursor based on the part.\n    grid.viewport.node.style.cursor = cursor;\n\n    // TODO support user-defined hover items\n  }\n\n  /**\n   * Handle the mouse leave event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseLeave(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined hover popups.\n\n    // Clear the viewport cursor.\n    grid.viewport.node.style.cursor = '';\n  }\n\n  /**\n   * Handle the mouse down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse down event of interest.\n   */\n  onMouseDown(grid: DataGrid, event: MouseEvent): void {\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    let { region, row, column } = hit;\n\n    // Bail if the hit test is on an uninteresting region.\n    if (region === 'void') {\n      return;\n    }\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // If the hit test is the body region, the only option is select.\n    if (region === 'body') {\n      // Fetch the selection model.\n      let model = grid.selectionModel;\n\n      // Bail early if there is no selection model.\n      if (!model) {\n        return;\n      }\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor('default');\n\n      // Set up the press data.\n      this._pressData = {\n        type: 'select', region, row, column, override,\n        localX: -1, localY: -1, timeout: -1\n      };\n\n      // Set up the selection variables.\n      let r1: number;\n      let c1: number;\n      let r2: number;\n      let c2: number;\n      let cursorRow: number;\n      let cursorColumn: number;\n      let clear: SelectionModel.ClearMode;\n\n      // Accel == new selection, keep old selections.\n      if (accel) {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'none';\n      } else if (shift) {\n        r1 = model.cursorRow;\n        r2 = row;\n        c1 = model.cursorColumn;\n        c2 = column;\n        cursorRow = model.cursorRow;\n        cursorColumn = model.cursorColumn;\n        clear = 'current';\n      } else {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'all';\n      }\n\n      // Use selection mode 'cell'\n      model.selectionMode = 'cell';\n\n      // Make the selection.\n      model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the hit test is on a header region.\n\n    // Convert the hit test into a part.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Handle horizontal resize.\n    if (handle === 'left' || handle === 'right' ) {\n      // Set up the resize data type.\n      let type: 'column-resize' = 'column-resize';\n\n      // Determine the column region.\n      let rgn: DataModel.ColumnRegion = (\n        region === 'column-header' ? 'body' : 'row-header'\n      );\n\n      // Determine the section index.\n      let index = handle === 'left' ? column - 1 : column;\n\n      // Fetch the section size.\n      let size = grid.columnSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientX, override };\n\n      // Done.\n      return;\n    }\n\n    // Handle vertical resize\n    if (handle === 'top' || handle === 'bottom') {\n      // Set up the resize data type.\n      let type: 'row-resize' = 'row-resize';\n\n      // Determine the row region.\n      let rgn: DataModel.RowRegion = (\n        region === 'row-header' ? 'body' : 'column-header'\n      );\n\n      // Determine the section index.\n      let index = handle === 'top' ? row - 1 : row;\n\n      // Fetch the section size.\n      let size = grid.rowSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientY, override };\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the only option is select.\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail if there is no selection model.\n    if (!model) {\n      return;\n    }\n\n    // Override the document cursor.\n    let override = Drag.overrideCursor('default');\n\n    // Set up the press data.\n    this._pressData = {\n      type: 'select', region, row, column, override,\n      localX: -1, localY: -1, timeout: -1\n    };\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow: number;\n    let cursorColumn: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Compute the selection based on the pressed region.\n    if (region === 'corner-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'row-header') {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'column-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    }\n\n    // Set selection mode based on region\n    switch (region) {\n      case 'column-header':\n        model.selectionMode = 'column';\n        break;\n      case 'row-header':\n        model.selectionMode = 'row';\n        break;\n      default:\n        model.selectionMode = 'cell';\n        break;\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse move event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse move event of interest.\n   */\n  onMouseMove(grid: DataGrid, event: MouseEvent): void {\n    // Fetch the press data.\n    const data = this._pressData;\n\n    // Bail early if there is no press data.\n    if (!data) {\n      return;\n    }\n\n    // Handle a row resize.\n    if (data.type === 'row-resize') {\n      let dy = event.clientY - data.clientY;\n      grid.resizeRow(data.region, data.index, data.size + dy);\n      return;\n    }\n\n    // Handle a column resize.\n    if (data.type === 'column-resize') {\n      let dx = event.clientX - data.clientX;\n      grid.resizeColumn(data.region, data.index, data.size + dx);\n      return;\n    }\n\n    // Otherwise, it's a select.\n\n    // Mouse moves during a corner header press are a no-op.\n    if (data.region === 'corner-header') {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model was removed.\n    if (!model) {\n      return;\n    }\n\n    // Map to local coordinates.\n    let { lx, ly } = grid.mapToLocal(event.clientX, event.clientY);\n\n    // Update the local mouse coordinates in the press data.\n    data.localX = lx;\n    data.localY = ly;\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n    let sx = grid.scrollX;\n    let sy = grid.scrollY;\n    let msx = grid.maxScrollY;\n    let msy = grid.maxScrollY;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Set up the timeout variable.\n    let timeout = -1;\n\n    // Compute the timemout based on hit region and mouse position.\n    if (data.region === 'row-header' || mode === 'row') {\n      if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    } else if (data.region === 'column-header' || mode === 'column') {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      }\n    } else {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      } else if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    }\n\n    // Update or initiate the autoselect if needed.\n    if (timeout >= 0) {\n      if (data.timeout < 0) {\n        data.timeout = timeout;\n        setTimeout(() => { Private.autoselect(grid, data); }, timeout);\n      } else {\n        data.timeout = timeout;\n      }\n      return;\n    }\n\n    // Otherwise, clear the autoselect timeout.\n    data.timeout = -1;\n\n    // Map the position to virtual coordinates.\n    let { vx, vy } = grid.mapToVirtual(event.clientX, event.clientY);\n\n    // Clamp the coordinates to the limits.\n    vx = Math.max(0, Math.min(vx, grid.bodyWidth -1));\n    vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Compute the selection based pressed region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r1 = data.row;\n      r2 = grid.rowAt('body', vy);\n      c1 = 0;\n      c2 = Infinity;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = data.column;\n      c2 = grid.columnAt('body', vx);\n    } else {\n      r1 = cursorRow;\n      r2 = grid.rowAt('body', vy);\n      c1 = cursorColumn;\n      c2 = grid.columnAt('body', vx);\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse up event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseUp(grid: DataGrid, event: MouseEvent): void {\n    this.release();\n  }\n\n  /**\n   * Handle the mouse double click event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void {\n    if (!grid.dataModel) {\n      this.release();\n      return;\n    }\n\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    let { region, row, column } = hit;\n\n    if (region === 'void') {\n      this.release();\n      return;\n    }\n\n    if (region === 'body') {\n      if (grid.editable) {\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n      }\n    }\n\n    this.release();\n  }\n\n  /**\n   * Handle the context menu event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The context menu event of interest.\n   */\n  onContextMenu(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined context menus\n  }\n\n  /**\n   * Handle the wheel event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The wheel event of interest.\n   */\n  onWheel(grid: DataGrid, event: WheelEvent): void {\n    // Bail if a mouse press is in progress.\n    if (this._pressData) {\n      return;\n    }\n\n    // Extract the delta X and Y movement.\n    let dx = event.deltaX;\n    let dy = event.deltaY;\n\n    // Convert the delta values to pixel values.\n    switch (event.deltaMode) {\n    case 0:  // DOM_DELTA_PIXEL\n      break;\n    case 1:  // DOM_DELTA_LINE\n      let ds = grid.defaultSizes;\n      dx *= ds.columnWidth;\n      dy *= ds.rowHeight;\n      break;\n    case 2:  // DOM_DELTA_PAGE\n      dx *= grid.pageWidth;\n      dy *= grid.pageHeight;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Scroll by the desired amount.\n    grid.scrollBy(dx, dy);\n  }\n\n/**\n* Convert a resize handle into a cursor.\n*/\ncursorForHandle(handle: ResizeHandle): string {\n  return Private.cursorMap[handle];\n}\n\n  private _disposed = false;\n  private _pressData: Private.PressData | null;\n}\n\n/**\n* A type alias for the resize handle types.\n*/\n  export\n  type ResizeHandle = 'top' | 'left' | 'right' | 'bottom' | 'none';\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A type alias for the row resize data.\n   */\n  export\n  type RowResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'row-resize';\n\n    /**\n     * The row region which holds the section being resized.\n     */\n    readonly region: DataModel.RowRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client Y position of the mouse.\n     */\n    readonly clientY: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the column resize data.\n   */\n  export\n  type ColumnResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'column-resize';\n\n    /**\n     * The column region which holds the section being resized.\n     */\n    readonly region: DataModel.ColumnRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client X position of the mouse.\n     */\n    readonly clientX: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the select data.\n   */\n  export\n  type SelectData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'select';\n\n    /**\n     * The original region for the mouse press.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The original row that was selected.\n     */\n    readonly row: number;\n\n    /**\n     * The original column that was selected.\n     */\n    readonly column: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n\n    /**\n     * The current local X position of the mouse.\n     */\n    localX: number;\n\n    /**\n     * The current local Y position of the mouse.\n     */\n    localY: number;\n\n    /**\n     * The timeout delay for the autoselect loop.\n     */\n    timeout: number;\n  };\n\n  /**\n   * A type alias for the resize handler press data.\n   */\n  export\n  type PressData = RowResizeData | ColumnResizeData | SelectData ;\n\n  /**\n   * Get the resize handle for a grid hit test.\n   */\n  export\n  function resizeHandleForHitTest(hit: DataGrid.HitTestResult): ResizeHandle {\n    // Fetch the row and column.\n    let r = hit.row;\n    let c = hit.column;\n\n    // Fetch the leading and trailing sizes.\n    let lw = hit.x;\n    let lh = hit.y;\n    let tw = hit.width - hit.x;\n    let th = hit.height - hit.y;\n\n    // Set up the result variable.\n    let result: ResizeHandle;\n\n    // Dispatch based on hit test region.\n    switch (hit.region) {\n    case 'corner-header':\n      if (c > 0 && lw <= 5) {\n        result = 'left';\n      } else if (tw <= 6) {\n        result = 'right';\n      } else if (r > 0 && lh <= 5) {\n        result = 'top';\n      } else if (th <= 6) {\n        result = 'bottom';\n      } else {\n        result = 'none';\n      }\n      break;\n    case 'column-header':\n      if (c > 0 && lw <= 5) {\n        result = 'left';\n      } else if (tw <= 6) {\n        result = 'right';\n      } else if (r > 0 && lh <= 5) {\n        result = 'top';\n      } else if (th <= 6) {\n        result = 'bottom';\n      } else {\n        result = 'none';\n      }\n      break;\n    case 'row-header':\n      if (c > 0 && lw <= 5) {\n        result = 'left';\n      } else if (tw <= 6) {\n        result = 'right';\n      } else if (r > 0 && lh <= 5) {\n        result = 'top';\n      } else if (th <= 6) {\n        result = 'bottom';\n      } else {\n        result = 'none';\n      }\n      break;\n    case 'body':\n      result = 'none';\n      break;\n    case 'void':\n      result = 'none';\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Return the result.\n    return result;\n  }\n\n  /**\n   * A timer callback for the autoselect loop.\n   *\n   * @param grid - The datagrid of interest.\n   *\n   * @param data - The select data of interest.\n   */\n  export\n  function autoselect(grid: DataGrid, data: SelectData): void {\n    // Bail early if the timeout has been reset.\n    if (data.timeout < 0) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model has been removed.\n    if (!model) {\n      return;\n    }\n\n    // Fetch the current selection.\n    let cs = model.currentSelection();\n\n    // Bail early if there is no current selection.\n    if (!cs) {\n      return;\n    }\n\n    // Fetch local X and Y coordinates of the mouse.\n    let lx = data.localX;\n    let ly = data.localY;\n\n    // Set up the selection variables.\n    let r1 = cs.r1;\n    let c1 = cs.c1;\n    let r2 = cs.r2;\n    let c2 = cs.c2;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Update the selection based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    } else {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    }\n\n    // Update the current selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return\n    }\n\n    // Scroll the grid based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else if (data.region === 'column-header' || mode == 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else if (mode === 'cell') {\n      grid.scrollToCell(cs.r2, cs.c2);\n    }\n\n    // Schedule the next call with the current timeout.\n    setTimeout(() => { autoselect(grid, data); }, data.timeout);\n  }\n\n  /**\n   * Compute the scroll timeout for the given delta distance.\n   *\n   * @param delta - The delta pixels from the origin.\n   *\n   * @returns The scaled timeout in milliseconds.\n   */\n  export\n  function computeTimeout(delta: number): number {\n    return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);\n  }\n\n  /**\n   * A mapping of resize handle to cursor.\n   */\n  export\n  const cursorMap = {\n    top: 'ns-resize',\n    left: 'ew-resize',\n    right: 'ew-resize',\n    bottom: 'ns-resize',\n    none: 'default'\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  Platform\n} from '@lumino/domutils';\n\nimport {\n  getKeyboardLayout\n} from '@lumino/keyboard';\n\nimport {\n  DataGrid\n} from './datagrid';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  CellEditor\n} from './celleditor';\n\nimport {\n  MutableDataModel\n} from './datamodel';\n\n\n/**\n * A basic implementation of a data grid key handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport\nclass BasicKeyHandler implements DataGrid.IKeyHandler {\n  /**\n   * Whether the key handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by the key handler.\n   */\n  dispose(): void {\n    this._disposed = true;\n  }\n\n  /**\n   * Handle the key down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keydown event of interest.\n   *\n   * #### Notes\n   * This will not be called if the mouse button is pressed.\n   */\n  onKeyDown(grid: DataGrid, event: KeyboardEvent): void {\n    // if grid is editable and cell selection available, start cell editing\n    // on key press (letters, numbers and space only)\n    if (grid.editable && \n      grid.selectionModel!.cursorRow !== -1 &&\n      grid.selectionModel!.cursorColumn !== -1) {\n      const input = String.fromCharCode(event.keyCode);\n      if (/[a-zA-Z0-9-_ ]/.test(input)) {\n        const row = grid.selectionModel!.cursorRow;\n        const column = grid.selectionModel!.cursorColumn;\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n        if (getKeyboardLayout().keyForKeydownEvent(event) === 'Space') {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        return;\n      }\n    }\n\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n    case 'ArrowLeft':\n      this.onArrowLeft(grid, event);\n      break;\n    case 'ArrowRight':\n      this.onArrowRight(grid, event);\n      break;\n    case 'ArrowUp':\n      this.onArrowUp(grid, event);\n      break;\n    case 'ArrowDown':\n      this.onArrowDown(grid, event);\n      break;\n    case 'PageUp':\n      this.onPageUp(grid, event);\n      break;\n    case 'PageDown':\n      this.onPageDown(grid, event);\n      break;\n    case 'Escape':\n      this.onEscape(grid, event);\n      break;\n    case 'Delete':\n      this.onDelete(grid, event);\n      break;\n    case 'C':\n      this.onKeyC(grid, event);\n      break;\n    case 'Enter':\n      if (grid.selectionModel) {\n        grid.moveCursor(event.shiftKey ? 'up' : 'down');\n        grid.scrollToCursor();\n      }\n      break;\n    case 'Tab':\n      if (grid.selectionModel) {\n        grid.moveCursor(event.shiftKey ? 'left' : 'right');\n        grid.scrollToCursor();\n        event.stopPropagation();\n        event.preventDefault();\n      }\n      break;\n    }\n  }\n\n  /**\n   * Handle the `'ArrowLeft'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowLeft(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection mode with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 - 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = 0;\n      c2 = 0;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c - 1;\n      c2 = c - 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowRight'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowRight(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection model with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = Infinity;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 + 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = Infinity;\n      c2 = Infinity;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c + 1;\n      c2 = c + 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = 0;\n      r2 = 0;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r - 1;\n      r2 = r - 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = Infinity;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = Infinity;\n      r2 = Infinity;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r + 1;\n      r2 = r + 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'PageUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('up');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n =  Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 - n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'PageDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('down');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n =  Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 + n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'Escape'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onEscape(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.selectionModel) {\n      grid.selectionModel.clear();\n    }\n  }\n\n  /**\n   * Handle the `'Delete'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onDelete(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.editable &&\n      !grid.selectionModel!.isEmpty) {\n      const dataModel = grid.dataModel as MutableDataModel;\n      // Fetch the max row and column.\n      let maxRow = dataModel.rowCount('body') - 1;\n      let maxColumn = dataModel.columnCount('body') - 1;\n\n      const it = grid.selectionModel!.selections();\n      let s: SelectionModel.Selection | undefined;\n      while ((s = it.next()) !== undefined) {\n        // Clamp the cell to the model bounds.\n        let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n        let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n        let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n        let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n        for (let r = sr1; r <= sr2; ++r) {\n          for (let c = sc1; c <= sc2; ++c) {\n            dataModel.setData('body', r, c, null);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle the `'C'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onKeyC(grid: DataGrid, event: KeyboardEvent): void {\n    // Bail early if the modifiers aren't correct for copy.\n    if (event.shiftKey || !Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Copy the current selection to the clipboard.\n    grid.copyToClipboard();\n  }\n\n  private _disposed = false;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IIterator, some\n} from '@lumino/algorithm';\n\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\nimport {\n  DataModel\n} from './datamodel';\n\n\n/**\n * A base class for creating data grid selection models.\n *\n * #### Notes\n * If the predefined selection models are insufficient for a particular\n * use case, a custom model can be defined which derives from this class.\n */\nexport\nabstract class SelectionModel {\n  /**\n   * Construct a new selection model.\n   *\n   * @param options - The options for initializing the model.\n   */\n  constructor(options: SelectionModel.IOptions) {\n    this.dataModel = options.dataModel;\n    this._selectionMode = options.selectionMode || 'cell';\n    this.dataModel.changed.connect(this.onDataModelChanged, this);\n  }\n\n  /**\n   * Whether the selection model is empty.\n   *\n   * #### Notes\n   * An empty selection model will yield an empty `selections` iterator.\n   */\n  abstract readonly isEmpty: boolean;\n\n  /**\n   * The row index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorRow: number;\n\n  /**\n   * The column index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorColumn: number;\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   * \n   * @param direction - The direction of the movement.\n   */\n  abstract moveCursorWithinSelections(direction: SelectionModel.CursorMoveDirection): void;\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  abstract currentSelection(): SelectionModel.Selection | null;\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the selections in the model.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  abstract selections(): IIterator<SelectionModel.Selection>;\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  abstract select(args: SelectionModel.SelectArgs): void;\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  abstract clear(): void;\n\n  /**\n   * A signal emitted when the selection model has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * The data model associated with the selection model.\n   */\n  readonly dataModel: DataModel;\n\n  /**\n   * Get the selection mode for the model.\n   */\n  get selectionMode(): SelectionModel.SelectionMode {\n    return this._selectionMode;\n  }\n\n  /**\n   * Set the selection mode for the model.\n   *\n   * #### Notes\n   * This will clear the selection model.\n   */\n  set selectionMode(value: SelectionModel.SelectionMode) {\n    // Bail early if the mode does not change.\n    if (this._selectionMode === value) {\n      return;\n    }\n\n    // Update the internal mode.\n    this._selectionMode = value;\n\n    // Clear the current selections.\n    this.clear();\n  }\n\n  /**\n   * Test whether any selection intersects a row.\n   *\n   * @param index - The row index of interest.\n   *\n   * @returns Whether any selection intersects the row.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isRowSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsRow(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a column.\n   *\n   * @param index - The column index of interest.\n   *\n   * @returns Whether any selection intersects the column.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isColumnSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsColumn(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a cell.\n   *\n   * @param row - The row index of interest.\n   *\n   * @param column - The column index of interest.\n   *\n   * @returns Whether any selection intersects the cell.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isCellSelected(row: number, column: number): boolean {\n    return some(this.selections(), s => Private.containsCell(s, row, column));\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   *\n   * #### Notes\n   * Selection model implementations should update their selections\n   * in a manner that is relevant for the changes to the data model.\n   *\n   * The default implementation of this method is a no-op.\n   */\n  protected onDataModelChanged(sender: DataModel, args: DataModel.ChangedArgs): void { }\n\n  /**\n   * Emit the `changed` signal for the selection model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the selection model\n   * has changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(): void {\n    this._changed.emit(undefined);\n  }\n\n  private _changed = new Signal<this, void>(this);\n  private _selectionMode: SelectionModel.SelectionMode = 'cell';\n}\n\n\n/**\n * The namespace for the `SelectionModel` class statics.\n */\nexport\nnamespace SelectionModel {\n  /**\n   * A type alias for the selection mode.\n   */\n  export\n  type SelectionMode = 'row' | 'column' | 'cell';\n  \n  /**\n   * A type alias for the cursor move direction.\n   */\n  export type CursorMoveDirection = 'up' | 'down' | 'left' | 'right' | 'none';\n\n  /**\n   * A type alias for the clear mode.\n   */\n  export\n  type ClearMode = 'all' | 'current' | 'none';\n\n  /**\n   * A type alias for the select args.\n   */\n  export\n  type SelectArgs = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    c2: number;\n\n    /**\n     * The row index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorRow: number;\n\n    /**\n     * The column index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorColumn: number;\n\n    /**\n     * Which of the existing selections to clear.\n     */\n    clear: ClearMode;\n  };\n\n  /**\n   * A type alias for a selection in a selection model.\n   */\n  export\n  type Selection = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    readonly r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    readonly c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    readonly r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    readonly c2: number;\n  };\n\n  /**\n   * An options object for initializing a selection model.\n   */\n  export\n  interface IOptions {\n    /**\n     * The data model for the selection model.\n     */\n    dataModel: DataModel;\n\n    /**\n     * The selection mode for the model.\n     *\n     * The default is `'cell'`.\n     */\n    selectionMode?: SelectionMode;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Test whether a selection contains a given row.\n   */\n  export\n  function containsRow(selection: SelectionModel.Selection, row: number): boolean {\n    let { r1, r2 } = selection;\n    return (row >= r1 && row <= r2) || (row >= r2 && row <= r1);\n  }\n\n  /**\n   * Test whether a selection contains a given column.\n   */\n  export\n  function containsColumn(selection: SelectionModel.Selection, column: number): boolean {\n    let { c1, c2 } = selection;\n    return (column >= c1 && column <= c2) || (column >= c2 && column <= c1);\n  }\n\n  /**\n   * Test whether a selection contains a given cell.\n   */\n  export\n  function containsCell(selection: SelectionModel.Selection, row: number, column: number): boolean {\n    return containsRow(selection, row) && containsColumn(selection, column);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IIterator, iter\n} from '@lumino/algorithm';\n\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\n\n/**\n * A basic selection model implementation.\n *\n * #### Notes\n * This selection model is sufficient for most use cases where\n * structural knowledge of the data source is *not* required.\n */\nexport\nclass BasicSelectionModel extends SelectionModel {\n  /**\n   * Wether the selection model is empty.\n   */\n  get isEmpty(): boolean {\n    return this._selections.length === 0;\n  }\n\n  /**\n   * The row index of the cursor.\n   */\n  get cursorRow(): number {\n    return this._cursorRow;\n  }\n\n  /**\n   * The column index of the cursor.\n   */\n  get cursorColumn(): number {\n    return this._cursorColumn;\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   * \n   * @param direction - The direction of the movement.\n   */\n  moveCursorWithinSelections(direction: SelectionModel.CursorMoveDirection): void {\n    // Bail early if there are no selections or no existing cursor\n    if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {\n      return;\n    }\n\n    // Bail early if only single cell is selected\n    const firstSelection = this._selections[0];\n    if (this._selections.length === 1 &&\n      firstSelection.r1 === firstSelection.r2 &&\n      firstSelection.c1 === firstSelection.c2) {\n      return;\n    }\n\n    // start from last selection rectangle\n    if (this._cursorRectIndex === -1) {\n      this._cursorRectIndex = this._selections.length - 1;\n    }\n\n    let cursorRect = this._selections[this._cursorRectIndex];\n    const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n    const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n    let newRow = this._cursorRow + dr;\n    let newColumn = this._cursorColumn + dc;\n    const r1 = Math.min(cursorRect.r1, cursorRect.r2);\n    const r2 = Math.max(cursorRect.r1, cursorRect.r2);\n    const c1 = Math.min(cursorRect.c1, cursorRect.c2);\n    const c2 = Math.max(cursorRect.c1, cursorRect.c2);\n\n    const moveToNextRect = () => {\n      this._cursorRectIndex = (this._cursorRectIndex + 1) % this._selections.length;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.min(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.min(cursorRect.c1, cursorRect.c2);\n    };\n    \n    const moveToPreviousRect = () => {\n      this._cursorRectIndex = this._cursorRectIndex === 0 ? this._selections.length - 1 : this._cursorRectIndex - 1;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.max(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.max(cursorRect.c1, cursorRect.c2);\n    };\n\n    if (newRow > r2) {\n      newRow = r1;\n      newColumn += 1;\n      if (newColumn > c2) {\n        moveToNextRect();\n      }\n    } else if (newRow < r1) {\n      newRow = r2;\n      newColumn -= 1;\n      if (newColumn < c1) {\n        moveToPreviousRect();\n      }\n    } else if (newColumn > c2) {\n      newColumn = c1;\n      newRow += 1;\n      if (newRow > r2) {\n        moveToNextRect();\n      }\n    } else if (newColumn < c1) {\n      newColumn = c2;\n      newRow -= 1;\n      if (newRow < r1) {\n        moveToPreviousRect();\n      }\n    }\n\n    this._cursorRow = newRow;\n    this._cursorColumn = newColumn;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  currentSelection(): SelectionModel.Selection | null {\n    return this._selections[this._selections.length - 1] || null;\n  }\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the current selections.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  selections(): IIterator<SelectionModel.Selection> {\n    return iter(this._selections);\n  }\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  select(args: SelectionModel.SelectArgs): void {\n    // Fetch the current row and column counts;\n    let rowCount = this.dataModel.rowCount('body');\n    let columnCount = this.dataModel.columnCount('body');\n\n    // Bail early if there is no content.\n    if (rowCount <= 0 || columnCount <= 0) {\n      return;\n    }\n\n    // Unpack the arguments.\n    let { r1, c1, r2, c2, cursorRow, cursorColumn, clear } = args;\n\n    // Clear the necessary selections.\n    if (clear === 'all') {\n      this._selections.length = 0;\n    } else if (clear === 'current') {\n      this._selections.pop();\n    }\n\n    // Clamp to the data model bounds.\n    r1 = Math.max(0, Math.min(r1, rowCount - 1));\n    r2 = Math.max(0, Math.min(r2, rowCount - 1));\n    c1 = Math.max(0, Math.min(c1, columnCount - 1));\n    c2 = Math.max(0, Math.min(c2, columnCount - 1));\n\n    // Handle the selection mode.\n    if (this.selectionMode === 'row') {\n      c1 = 0;\n      c2 = columnCount - 1;\n    } else if (this.selectionMode === 'column') {\n      r1 = 0;\n      r2 = rowCount - 1;\n    }\n\n    // Alias the cursor row and column.\n    let cr = cursorRow;\n    let cc = cursorColumn;\n\n    // Compute the new cursor location.\n    if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {\n      cr = r1;\n    }\n    if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {\n      cc = c1;\n    }\n\n    // Update the cursor.\n    this._cursorRow = cr;\n    this._cursorColumn = cc;\n    this._cursorRectIndex = this._selections.length;\n\n    // Add the new selection.\n    this._selections.push({ r1, c1, r2, c2 });\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  clear(): void {\n    // Bail early if there are no selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Reset the internal state.\n    this._cursorRow = -1;\n    this._cursorColumn = -1;\n    this._cursorRectIndex = -1;\n    this._selections.length = 0;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   */\n  protected onDataModelChanged(sender: DataModel, args: DataModel.ChangedArgs): void {\n    // Bail early if the model has no current selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Bail early if the cells have changed in place.\n    if (args.type === 'cells-changed') {\n      return;\n    }\n\n    // Bail early if there is no change to the row or column count.\n    if (args.type === 'rows-moved' || args.type === 'columns-moved') {\n      return;\n    }\n\n    // Fetch the last row and column index.\n    let lr = sender.rowCount('body') - 1;\n    let lc = sender.columnCount('body') - 1;\n\n    // Bail early if the data model is empty.\n    if (lr < 0 || lc < 0) {\n      this._selections.length = 0;\n      this.emitChanged();\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = this.selectionMode;\n\n    // Set up the assignment index variable.\n    let j = 0;\n\n    // Iterate over the current selections.\n    for (let i = 0, n = this._selections.length; i < n; ++i) {\n      // Unpack the selection.\n      let { r1, c1, r2, c2 } = this._selections[i];\n\n      // Skip the selection if it will disappear.\n      if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {\n        continue;\n      }\n\n      // Modify the bounds based on the selection mode.\n      if (mode === 'row') {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = 0;\n        c2 = lc;\n      } else if (mode === 'column') {\n        r1 = 0;\n        r2 = lr;\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      } else {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      }\n\n      // Assign the modified selection to the array.\n      this._selections[j++] = { r1, c1, r2, c2 };\n    }\n\n    // Remove the stale selections.\n    this._selections.length = j;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  private _cursorRow = -1;\n  private _cursorColumn = -1;\n  private _cursorRectIndex = -1;\n  private _selections: SelectionModel.Selection[] = [];\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  GraphicsContext\n} from './graphicscontext';\n\n\n/**\n * An object which renders the cells of a data grid.\n *\n * #### Notes\n * If the predefined cell renderers are insufficient for a particular\n * use case, a custom cell renderer can be defined which derives from\n * this class.\n *\n * The data grid renders cells in column-major order, by region. The\n * region order is: body, row header, column header, corner header.\n */\nexport\nabstract class CellRenderer {\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   *\n   * #### Notes\n   * The grid will save/restore the `gc` state before/after invoking\n   * the renderer.\n   *\n   * For performance, the cell content is efficiently clipped to the\n   * width of the column, but *the height is not clipped*. If height\n   * clipping is needed, the renderer must set up its own clip rect.\n   *\n   * The renderer **must not** draw outside the cell bounding height.\n   */\n  abstract paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void;\n}\n\n\n/**\n * The namespace for the `CellRenderer` class statics.\n */\nexport\nnamespace CellRenderer {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export\n  type CellConfig = {\n    /**\n     * The X position of the cell rectangle, in viewport coordinates.\n     */\n    readonly x: number;\n\n    /**\n     * The Y position of the cell rectangle, in viewport coordinates.\n     */\n    readonly y: number;\n\n    /**\n     * The height of the cell rectangle, in viewport pixels.\n     */\n    readonly height: number;\n\n    /**\n     * The width of the cell rectangle, in viewport pixels.\n     */\n    readonly width: number;\n\n    /**\n     * The region for the cell.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n\n    /**\n     * The value for the cell.\n     */\n    readonly value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    readonly metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a cell renderer config function.\n   *\n   * This type is used to compute a value from a cell config object.\n   */\n  export\n  type ConfigFunc<T> = (config: CellConfig) => T;\n\n  /**\n   * A type alias for a cell renderer config option.\n   *\n   * A config option can be a static value or a config function.\n   */\n  export\n  type ConfigOption<T> = T | ConfigFunc<T>;\n\n  /**\n   * Resolve a config option for a cell renderer.\n   *\n   * @param option - The config option to resolve.\n   *\n   * @param config - The cell config object.\n   *\n   * @returns The resolved value for the option.\n   */\n  export\n  function resolveOption<T>(option: ConfigOption<T>, config: CellConfig): T {\n    return typeof option === 'function' ? (option as ConfigFunc<T>)(config) : option;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport {\n  Message\n} from '@lumino/messaging';\n\nimport {\n  Widget\n} from '@lumino/widgets';\n\n\n/**\n * A widget which implements a notification popup.\n */\nexport\nclass Notification extends Widget {\n  /**\n   * Construct a new notification.\n   *\n   * @param options - The options for initializing the notification.\n   */\n  constructor(options: Notification.IOptions) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-DataGrid-notification');\n    this.setFlag(Widget.Flag.DisallowLayout);\n\n    this._target = options.target;\n    this._message = options.message || '';\n    this._placement = options.placement || 'bottom';\n\n    Widget.attach(this, document.body);\n\n    if (options.timeout && options.timeout > 0) {\n      setTimeout(() => {\n        this.close();\n      }, options.timeout);\n    }\n  }\n\n  /**\n   * Handle the DOM events for the notification.\n   *\n   * @param event - The DOM event sent to the notification.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the notification's DOM node.\n   *\n   * This should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n    case 'mousedown':\n      this._evtMouseDown(event as MouseEvent);\n      break;\n    case 'contextmenu':\n      event.preventDefault();\n      event.stopPropagation();\n      break;\n    }\n  }\n\n  /**\n   * Get the placement of the notification.\n   */\n  get placement(): Notification.Placement {\n    return this._placement;\n  }\n\n  /**\n   * Set the placement of the notification.\n   */\n  set placement(value: Notification.Placement) {\n    // Do nothing if the placement does not change.\n    if (this._placement === value) {\n      return;\n    }\n\n    // Update the internal placement.\n    this._placement = value;\n\n    // Schedule an update for notification.\n    this.update();\n  }\n\n  /**\n   * Get the current value of the message.\n   */\n  get message(): string {\n    return this._message;\n  }\n\n  /**\n   * Set the current value of the message.\n   *\n   */\n  set message(value: string) {\n    // Do nothing if the value does not change.\n    if (this._message === value) {\n      return;\n    }\n\n    // Update the internal value.\n    this._message = value;\n\n    // Schedule an update for notification.\n    this.update();\n  }\n\n  /**\n   * Get the node presenting the message.\n   */\n  get messageNode(): HTMLSpanElement {\n    return this.node.getElementsByClassName('lm-DataGrid-notificationMessage')[0] as HTMLSpanElement;\n  }\n\n  /**\n   * A method invoked on a 'before-attach' message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('mousedown', this);\n    this.update();\n  }\n\n  /**\n   * A method invoked on an 'after-detach' message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('mousedown', this);\n  }\n\n  /**\n   * A method invoked on an 'update-request' message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    const targetRect = this._target.getBoundingClientRect();\n    const style = this.node.style;\n\n    switch (this._placement) {\n      case 'bottom':\n        style.left = targetRect.left + 'px';\n        style.top = targetRect.bottom + 'px';\n        break;\n      case 'top':\n        style.left = targetRect.left + 'px';\n        style.height = targetRect.top + 'px';\n        style.top = '0';\n        style.alignItems = 'flex-end';\n        style.justifyContent = 'flex-end';\n        break;\n      case 'left':\n        style.left = '0';\n        style.width = targetRect.left + 'px';\n        style.top = targetRect.top + 'px';\n        style.alignItems = 'flex-end';\n        style.justifyContent = 'flex-end';\n        break;\n      case 'right':\n        style.left = targetRect.right + 'px';\n        style.top = targetRect.top + 'px';\n        break;\n    }\n\n    this.messageNode.innerHTML = this._message;\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the notification.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Do nothing if it's not a left mouse press.\n    if (event.button !== 0) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    this.close();\n  }\n\n  private _target: HTMLElement;\n  private _message: string = '';\n  private _placement: Notification.Placement;\n}\n\n\n/**\n * The namespace for the `Notification` class statics.\n */\nexport\nnamespace Notification {\n  /**\n   * A type alias for a notification placement.\n   */\n  export\n  type Placement = 'top' | 'bottom' | 'left' | 'right';\n\n  /**\n   * An options object for creating a notification.\n   */\n  export\n  interface IOptions {\n    /**\n     * Target element to attach notification to.\n     *\n     */\n    target: HTMLElement;\n\n    /**\n     * The message to show on notification.\n     */\n    message?: string;\n\n    /**\n     * The placement of the notification.\n     *\n     * The default is `'bottom'`.\n     */\n    placement?: Placement;\n\n    /**\n     * Duration in ms after which to close notification popup.\n     *\n     * The default is undefined, and notification is kept visible\n     * Timeout value needs to be greater than zero\n     */\n    timeout?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create the DOM node for notification.\n   */\n  export\n  function createNode(): HTMLElement {\n    const node = document.createElement('div');\n    const container = document.createElement('div');\n    container.className = 'lm-DataGrid-notificationContainer';\n    const message = document.createElement('span');\n    message.className = 'lm-DataGrid-notificationMessage';\n    container.appendChild(message);\n    node.appendChild(container);\n\n    return node;\n  }\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\nimport {\n  DataGrid\n} from './datagrid';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  getKeyboardLayout\n} from '@lumino/keyboard';\n\nimport {\n  Signal\n} from '@lumino/signaling';\n\nimport {\n  Notification\n} from './notification';\n\n/**\n * A response object returned from cell input validator\n */\nexport\ninterface ICellInputValidatorResponse {\n  /**\n   * Flag indicating cell input is valid or not\n   */\n  valid: boolean;\n  /**\n   * Validation error message. Set only when input is invalid\n   */\n  message?: string;\n}\n\n/**\n * An object which validates cell input values.\n */\nexport\ninterface ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: any): ICellInputValidatorResponse;\n}\n\n/**\n * An object returned from cell editor after a successful edit.\n */\nexport\ninterface ICellEditResponse {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  cell: CellEditor.CellConfig;\n  /**\n   * Value input.\n   */\n  value: any;\n  /**\n   * Cursor move direction based on keys pressed to end the edit.\n   */\n  cursorMovement: SelectionModel.CursorMoveDirection;\n}\n\n/**\n * An object implementing cell editing.\n */\nexport\ninterface ICellEditor {\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void;\n  /**\n   * Cancel editing the cell.\n   */\n  cancel(): void;\n}\n\n// default validation error message\nconst DEFAULT_INVALID_INPUT_MESSAGE = \"Invalid input!\";\n\n// A type alias for available cell data types\nexport\ntype CellDataType = 'string' | 'number' | 'integer' | 'boolean' | 'date' |\n                    'string:option' | 'number:option' | 'integer:option'| 'date:option'|\n                    'string:dynamic-option' | 'number:dynamic-option' | 'integer:dynamic-option' | 'date:dynamic-option';\n\n/**\n * An object containing cell editing options.\n */\nexport\ninterface ICellEditOptions {\n  /**\n   * Cell editor to use for editing.\n   * \n   * #### Notes\n   * This object is only used by cell editor controller.\n   * If not set, controller picks the most suitable editor\n   * for the particular cell configuration.\n   */\n  editor?: ICellEditor;\n  /**\n   * Cell input validator to use for value validation.\n   */\n  validator?: ICellInputValidator;\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  onCancel?: () => void;\n}\n\n/**\n * A cell input validator object which always returns valid.\n */\nexport\nclass PassInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: any): ICellInputValidatorResponse {\n    return { valid: true };\n  }\n}\n\n/**\n * Text cell input validator.\n */\nexport\nclass TextInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: string): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (typeof value !== 'string') {\n      return {\n        valid: false,\n        message: 'Input must be valid text'\n      };\n    }\n\n    if (!isNaN(this.minLength) && value.length < this.minLength) {\n      return {\n        valid: false,\n        message: `Text length must be greater than ${this.minLength}`\n      };\n    }\n\n    if (!isNaN(this.maxLength) && value.length > this.maxLength) {\n      return {\n        valid: false,\n        message: `Text length must be less than ${this.maxLength}`\n      };\n    }\n\n    if (this.pattern && !this.pattern.test(value)) {\n      return {\n        valid: false,\n        message: `Text doesn't match the required pattern`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum text length\n   * \n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  minLength: number = Number.NaN;\n  /**\n   * Maximum text length\n   * \n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  maxLength: number = Number.NaN;\n  /**\n   * Required text pattern as regular expression\n   * \n   * The default is null, meaning no pattern constraint\n   */\n  pattern: RegExp | null = null;\n}\n\n/**\n * Integer cell input validator.\n */\nexport\nclass IntegerInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: number): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value) || (value % 1 !== 0)) {\n      return {\n        valid: false,\n        message: 'Input must be valid integer'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   * \n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   * \n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n/**\n * Real number cell input validator.\n */\nexport\nclass NumberInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: number): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value)) {\n      return {\n        valid: false,\n        message: 'Input must be valid number'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   * \n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   * \n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n\n/**\n * An abstract base class that provides the most of the functionality\n * needed by a cell editor. All of the built-in cell editors\n * for various cell types are derived from this base class. Custom cell editors\n * can be easily implemented by extending this class.\n */\nexport\nabstract class CellEditor implements ICellEditor, IDisposable {\n  /**\n   * Construct a new cell editor.\n   */\n  constructor() {\n    this.inputChanged.connect(() => {\n      this.validate();\n    });\n  }\n\n  /**\n   * Whether the cell editor is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return;\n    }\n\n    if (this._gridWheelEventHandler) {\n      this.cell.grid.node.removeEventListener('wheel', this._gridWheelEventHandler);\n      this._gridWheelEventHandler = null;\n    }\n\n    this._closeValidityNotification();\n\n    this._disposed = true;\n    this.cell.grid.node.removeChild(this.viewportOccluder);\n  }\n\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void {\n    this.cell = cell;\n    this.onCommit = options && options.onCommit;\n    this.onCancel = options && options.onCancel;\n\n    this.validator = (options && options.validator) ? options.validator : this.createValidatorBasedOnType();\n\n    this._gridWheelEventHandler = () => {\n      this._closeValidityNotification();\n      this.updatePosition();\n    };\n\n    cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);\n\n    this._addContainer();\n\n    this.updatePosition();\n    this.startEditing();\n  }\n\n  /**\n   * Cancel editing the cell.\n   */\n  cancel() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.dispose();\n    if (this.onCancel) {\n      this.onCancel();\n    }\n  }\n\n  /**\n   * Start editing the cell. Usually an editor widget is created and\n   *  added to `editorContainer`\n   */\n  protected abstract startEditing(): void;\n  /**\n   * Return the current input entered. This method throws exceptions\n   * if input is invalid. Error message in exception is shown as notification.\n   */\n  protected abstract getInput(): any;\n\n  /**\n   * Whether the value input is valid.\n   */\n  protected get validInput(): boolean {\n    return this._validInput;\n  }\n\n  /**\n   * Validate the cell input. Shows validation error notification when input is invalid.\n   */\n  protected validate() {\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);\n      return;\n    }\n\n    if (this.validator) {\n      const result = this.validator.validate(this.cell, value);\n      if (result.valid) {\n        this.setValidity(true);\n      } else {\n        this.setValidity(false, result.message || DEFAULT_INVALID_INPUT_MESSAGE);\n      }\n    } else {\n      this.setValidity(true);\n    }\n  }\n\n  /**\n   * Set validity flag.\n   *\n   * @param valid - Whether the input is valid.\n   *\n   * @param message - Notification message to show.\n   * \n   * If message is set to empty string (which is the default)\n   * existing notification popup is removed if any.\n   */\n  protected setValidity(valid: boolean, message: string = \"\") {\n    this._validInput = valid;\n\n    this._closeValidityNotification();\n\n    if (valid) {\n      this.editorContainer.classList.remove('lm-mod-invalid');\n    } else {\n      this.editorContainer.classList.add('lm-mod-invalid');\n\n      // show a notification popup\n      if (message !== \"\") {\n        this.validityNotification = new Notification({\n          target: this.editorContainer,\n          message: message,\n          placement: 'bottom',\n          timeout: 5000\n        });\n        this.validityNotification.show();\n      }\n    }\n  }\n\n  /**\n   * Create and return a cell input validator based on configuration of the\n   * cell being edited. If no suitable validator can be found, it returns undefined.\n   */\n  protected createValidatorBasedOnType(): ICellInputValidator | undefined {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n\n    switch (metadata && metadata.type) {\n      case 'string':\n        {\n          const validator = new TextInputValidator();\n          if (typeof(metadata!.format) === 'string') {\n            const format = metadata!.format;\n            switch (format) {\n              case 'email':\n                validator.pattern = new RegExp(\"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$\");\n                break;\n              case 'uuid':\n                validator.pattern = new RegExp(\"[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}\");\n                break;\n              case 'uri':\n                // TODO\n                break;\n              case 'binary':\n                // TODO\n                break;\n            }\n          }\n\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minLength !== undefined) {\n              validator.minLength = metadata!.constraint.minLength;\n            }\n            if (metadata!.constraint.maxLength !== undefined) {\n              validator.maxLength = metadata!.constraint.maxLength;\n            }\n            if (typeof(metadata!.constraint.pattern) === 'string') {\n              validator.pattern = new RegExp(metadata!.constraint.pattern);\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'number':\n        {\n          const validator = new NumberInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'integer':\n        {\n          const validator = new IntegerInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Compute cell rectangle and return with other cell properties.\n   */\n  protected getCellInfo(cell: CellEditor.CellConfig): Private.ICellInfo {\n    const { grid, row, column } = cell;\n    const data = grid.dataModel!.data('body', row, column);\n\n    const columnX = grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);\n    const rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);\n    const width = grid.columnSize('body', column);\n    const height = grid.rowSize('body', row);\n\n    return {\n      grid: grid,\n      row: row,\n      column: column,\n      data: data,\n      x: columnX,\n      y: rowY,\n      width: width,\n      height: height\n    };\n  }\n\n  /**\n   * Reposition cell editor by moving viewport occluder and cell editor container.\n   */\n  protected updatePosition(): void {\n    const grid = this.cell.grid;\n    const cellInfo = this.getCellInfo(this.cell);\n    const headerHeight = grid.headerHeight;\n    const headerWidth = grid.headerWidth;\n\n    this.viewportOccluder.style.top = headerHeight + 'px';\n    this.viewportOccluder.style.left = headerWidth + 'px';\n    this.viewportOccluder.style.width = (grid.viewportWidth - headerWidth) + 'px';\n    this.viewportOccluder.style.height = (grid.viewportHeight - headerHeight) + 'px';\n    this.viewportOccluder.style.position = 'absolute';\n\n    this.editorContainer.style.left = (cellInfo.x - 1 - headerWidth) + 'px';\n    this.editorContainer.style.top = (cellInfo.y - 1 - headerHeight) + 'px';\n    this.editorContainer.style.width = (cellInfo.width + 1) + 'px';\n    this.editorContainer.style.height = (cellInfo.height + 1) + 'px';\n    this.editorContainer.style.visibility = 'visible';\n    this.editorContainer.style.position = 'absolute';\n  }\n\n  /**\n   * Commit the edited value.\n   * \n   * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.\n   * \n   * @returns true on valid input, false otherwise.\n   */\n  protected commit(cursorMovement: SelectionModel.CursorMoveDirection = 'none'): boolean {\n    this.validate();\n\n    if (!this._validInput) {\n      return false;\n    }\n\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      return false;\n    }\n\n    this.dispose();\n\n    if (this.onCommit) {\n      this.onCommit({\n        cell: this.cell,\n        value: value,\n        cursorMovement: cursorMovement\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Create container elements needed to prevent editor widget overflow\n   * beyond viewport and to position cell editor widget.\n   */\n  private _addContainer() {\n    this.viewportOccluder = document.createElement('div');\n    this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';\n    this.cell.grid.node.appendChild(this.viewportOccluder);\n\n    this.editorContainer = document.createElement('div');\n    this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';\n    this.viewportOccluder.appendChild(this.editorContainer);\n\n    // update mouse event pass-through state based on input validity\n    this.editorContainer.addEventListener('mouseleave', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = this._validInput ? 'none' : 'auto';\n    });\n    this.editorContainer.addEventListener('mouseenter', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = 'none';\n    });\n  }\n\n  /**\n   * Remove validity notification popup.\n   */\n  private _closeValidityNotification() {\n    if (this.validityNotification) {\n      this.validityNotification.close();\n      this.validityNotification = null;\n    }\n  }\n\n  /**\n   * A signal emitted when input changes.\n   */\n  protected inputChanged = new Signal<this, void>(this);\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  protected onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  protected onCancel?: () => void;\n  /**\n   * Cell configuration data for the cell being edited.\n   */\n  protected cell: CellEditor.CellConfig;\n  /**\n   * Cell input validator to use for the cell being edited.\n   */\n  protected validator: ICellInputValidator | undefined;\n  /**\n   * The div element used to prevent editor widget overflow beyond grid viewport.\n   */\n  protected viewportOccluder: HTMLDivElement;\n  /**\n   * The div element used to contain and position editor widget.\n   */\n  protected editorContainer: HTMLDivElement;\n  /**\n   * Notification popup used to show validation error messages.\n   */\n  protected validityNotification: Notification | null = null;\n  /**\n   * Whether the cell editor is disposed.\n   */\n  private _disposed = false;\n  /**\n   * Whether the value input is valid.\n   */\n  private _validInput: boolean = true;\n  /**\n   * Grid wheel event handler.\n   */\n  private _gridWheelEventHandler: ((this: HTMLElement, ev: WheelEvent) => any) | null = null;\n}\n\n/**\n * Abstract base class with shared functionality\n * for cell editors which use HTML Input widget as editor.\n */\nexport\nabstract class InputCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n      case 'input':\n        this._onInput(event);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this.createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this.input.value = this.deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this.input);\n    this.input.focus();\n    this.input.select();\n\n    this.bindEvents();\n  }\n\n  protected deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  protected createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    input.spellcheck = false;\n    input.type = this.inputType;\n\n    this.input = input;\n  }\n\n  protected bindEvents() {\n    this.input.addEventListener('keydown', this);\n    this.input.addEventListener('blur', this);\n    this.input.addEventListener('input', this);\n  }\n\n  private _unbindEvents() {\n    this.input.removeEventListener('keydown', this);\n    this.input.removeEventListener('blur', this);\n    this.input.removeEventListener('input', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.input.focus();\n    }\n  }\n\n  private _onInput(event: Event) {\n    this.inputChanged.emit(void 0);\n  }\n\n  protected input: HTMLInputElement;\n  protected abstract inputType: string;\n}\n\n/**\n * Cell editor for text cells.\n */\nexport\nclass TextCellEditor extends InputCellEditor {\n  /**\n   * Return the current text input entered.\n   */\n  protected getInput(): string | null {\n    return this.input.value;\n  }\n\n  protected inputType: string = 'text';\n}\n\n/**\n * Cell editor for real number cells.\n */\nexport\nclass NumberCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    super.startEditing();\n\n    this.input.step = 'any';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current number input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    const floatValue = parseFloat(value);\n    if (isNaN(floatValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return floatValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for integer cells.\n */\nexport\nclass IntegerCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    super.startEditing();\n\n    this.input.step = '1';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current integer input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    let intValue = parseInt(value);\n    if (isNaN(intValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return intValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for date cells.\n */\nexport\nclass DateCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current date input entered.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.type = 'date';\n    input.pattern = \"\\d{4}-\\d{2}-\\d{2}\";\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * Cell editor for boolean cells.\n */\nexport\nclass BooleanCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        // fix focus loss problem in Safari and Firefox\n        this._input.focus();\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.checked = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current boolean input entered.\n   */\n  protected getInput(): boolean | null {\n    return this._input.checked;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return false;\n    }\n\n    return value == true;\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorCheckbox');\n    input.type = 'checkbox';\n    input.spellcheck = false;\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('mousedown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('mousedown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n\n/**\n * Cell editor for option cells.\n * \n * It supports multiple option selection. If cell metadata contains\n * type attribute 'array', then it behaves as a multi select.\n * In that case cell data is expected to be list of string values.\n */\nexport\nclass OptionCellEditor extends CellEditor {\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    super.dispose();\n\n    if (this._isMultiSelect) {\n      document.body.removeChild(this._select);\n    }\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    this._isMultiSelect = metadata.type === 'array';\n    this._createWidget();\n\n    if (this._isMultiSelect) {\n      this._select.multiple = true;\n      const values = this._deserialize(cellInfo.data) as string[];\n      for (let i = 0; i < this._select.options.length; ++i) {\n        const option = this._select.options.item(i);\n        option!.selected = values.indexOf(option!.value) !== -1;\n      }\n      document.body.appendChild(this._select);\n    } else {\n      this._select.value = this._deserialize(cellInfo.data) as string;\n      this.editorContainer.appendChild(this._select);\n    }\n\n    this._select.focus();\n\n    this._bindEvents();\n\n    this.updatePosition();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | string[] | null {\n    if (this._isMultiSelect) {\n      const input: string[] = [];\n      for (let i = 0; i < this._select.selectedOptions.length; ++i) {\n        input.push(this._select.selectedOptions.item(i)!.value);\n      }\n      return input;\n    } else {\n      return this._select.value;\n    }\n  }\n\n  /**\n   * Reposition cell editor.\n   */\n  protected updatePosition(): void {\n    super.updatePosition();\n\n    if (!this._isMultiSelect) {\n      return;\n    }\n\n    const cellInfo = this.getCellInfo(this.cell);\n\n    this._select.style.position = 'absolute';\n    const editorContainerRect = this.editorContainer.getBoundingClientRect();\n\n    this._select.style.left = editorContainerRect.left + 'px';\n    this._select.style.top = (editorContainerRect.top + cellInfo.height) + 'px';\n    this._select.style.width = editorContainerRect.width + 'px';\n    this._select.style.maxHeight = '60px';\n\n    this.editorContainer.style.visibility = 'hidden';\n  }\n\n  private _deserialize(value: any): string | string[] {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (this._isMultiSelect) {\n      const values: string[] = [];\n      if (Array.isArray(value)) {\n        for (let item of value) {\n          values.push(item.toString());\n        }\n      }\n      return values;\n    } else {\n      return value.toString();\n    }\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    const items = metadata.constraint.enum;\n\n    const select = document.createElement('select');\n    select.classList.add('lm-DataGrid-cellEditorWidget');\n    for (let item of items) {\n      const option = document.createElement(\"option\");\n      option.value = item;\n      option.text = item;\n      select.appendChild(option);\n    }\n\n    this._select = select;\n  }\n\n  private _bindEvents() {\n    this._select.addEventListener('keydown', this._onKeyDown.bind(this));\n    this._select.addEventListener('blur', this._onBlur.bind(this));\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._select.focus();\n    }\n  }\n\n  private _select: HTMLSelectElement;\n  private _isMultiSelect: boolean = false;\n}\n\n/**\n * Cell editor for option cells whose value can be any value\n * from set of pre-defined options or values that can be input by user.\n */\nexport\nclass DynamicOptionCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n    this._input.select();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const grid = cell.grid;\n    const dataModel = grid.dataModel!;\n    const rowCount = dataModel.rowCount('body');\n\n    const listId = 'cell-editor-list';\n    const list = document.createElement('datalist');\n    list.id = listId;\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    const valueSet = new Set<string>();\n    for (let r = 0; r < rowCount; ++r) {\n      const data = dataModel.data('body', r, cell.column);\n      if (data) {\n        valueSet.add(data);\n      }\n    }\n    valueSet.forEach((value: string) => {\n      const option = document.createElement(\"option\");\n      option.value = value;\n      option.text = value;\n      list.appendChild(option);\n    });\n    this.editorContainer.appendChild(list);\n    input.setAttribute('list', listId);\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n\n/**\n * The namespace for the `CellEditor` class statics.\n */\nexport\nnamespace CellEditor {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export\n  type CellConfig = {\n    /**\n     * The grid containing the cell.\n     */\n    readonly grid: DataGrid;\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n  };\n}\n\n/**\n * A namespace for module-private functionality.\n */\nnamespace Private {\n  /**\n   * A type alias for cell properties.\n   */\n  export type ICellInfo = {\n    grid: DataGrid,\n    row: number,\n    column: number,\n    data: any,\n    x: number,\n    y: number,\n    width: number,\n    height: number\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\n\n/**\n * An object which provides the data for a data grid.\n *\n * #### Notes\n * If the predefined data models are insufficient for a particular use\n * case, a custom model can be defined which derives from this class.\n */\nexport\nabstract class DataModel {\n  /**\n   * A signal emitted when the data model has changed.\n   */\n  get changed(): ISignal<this, DataModel.ChangedArgs> {\n    return this._changed;\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract rowCount(region: DataModel.RowRegion): number;\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract columnCount(region: DataModel.ColumnRegion): number;\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The data value for the specified cell.\n   *\n   * #### Notes\n   * The returned data should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   */\n  abstract data(region: DataModel.CellRegion, row: number, column: number): any;\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the specified cell.\n   *\n   * #### Notes\n   * The returned metadata should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   *\n   * The default implementation returns `{}`.\n   */\n  metadata(region: DataModel.CellRegion, row: number, column: number): DataModel.Metadata {\n    return DataModel.emptyMetadata;\n  }\n\n  /**\n   * Emit the `changed` signal for the data model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the data model has\n   * changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(args: DataModel.ChangedArgs): void {\n    this._changed.emit(args);\n  }\n\n  private _changed = new Signal<this, DataModel.ChangedArgs>(this);\n}\n\n/**\n * An object which provides the mutable data for a data grid.\n *\n * #### Notes\n * This object is an extension to `DataModel` and it only adds ability to\n * change data for cells.\n */\nexport\nabstract class MutableDataModel extends DataModel {\n  /**\n   * Set the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns true if succeeds, false otherwise.\n   *\n   */\n  abstract setData(region: DataModel.CellRegion, row: number, column: number, value: any): boolean;\n}\n\n\n/**\n * The namespace for the `DataModel` class statics.\n */\nexport\nnamespace DataModel {\n  /**\n   * A type alias for the data model row regions.\n   */\n  export\n  type RowRegion = 'body' | 'column-header';\n\n  /**\n   * A type alias for the data model column regions.\n   */\n  export\n  type ColumnRegion = 'body' | 'row-header';\n\n  /**\n   * A type alias for the data model cell regions.\n   */\n  export\n  type CellRegion = 'body' | 'row-header' | 'column-header' | 'corner-header';\n\n  /**\n   * The metadata for a column in a data model.\n   */\n  export\n  type Metadata = { [key: string]: any };\n\n  /**\n   * A singleton empty metadata object.\n   */\n  export\n  const emptyMetadata: Metadata = Object.freeze({});\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are inserted or removed.\n   */\n  export\n  type RowsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-inserted' | 'rows-removed';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are inserted or removed.\n   */\n  export\n  type ColumnsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-inserted' | 'columns-removed';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are moved.\n   */\n  export\n  type RowsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-moved';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The starting index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified row.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are moved.\n   */\n  export\n  type ColumnsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-moved';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The starting index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified column.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when cells are changed in-place.\n   */\n  export\n  type CellsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'cells-changed';\n\n    /**\n     * The region which contains the modified cells.\n     */\n    readonly region: CellRegion;\n\n    /**\n     * The row index of the first modified cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the first modified cell.\n     */\n    readonly column: number;\n\n    /**\n     * The number of rows in the modified cell range.\n     */\n    readonly rowSpan: number;\n\n    /**\n     * The number of columns in the modified cell range.\n     */\n    readonly columnSpan: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when the model has changed in a fashion that cannot be easily\n   * expressed by the other args object types.\n   *\n   * This is the \"big hammer\" approach, and will cause any associated\n   * data grid to perform a full reset. The other changed args types\n   * should be used whenever possible.\n   */\n  export\n  type ModelResetArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'model-reset';\n  };\n\n  /**\n   * A type alias for the args objects of the `changed` signal.\n   */\n  export\n  type ChangedArgs = (\n    RowsChangedArgs |\n    ColumnsChangedArgs |\n    RowsMovedArgs |\n    ColumnsMovedArgs |\n    CellsChangedArgs |\n    ModelResetArgs\n  );\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\n\n/**\n * A thin caching wrapper around a 2D canvas rendering context.\n *\n * #### Notes\n * This class is mostly a transparent wrapper around a canvas rendering\n * context which improves performance when writing context state.\n *\n * For best performance, avoid reading state from the `gc`. Writes are\n * cached based on the previously written value.\n *\n * Unless otherwise specified, the API and semantics of this class are\n * identical to the builtin 2D canvas rendering context:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n *\n * The wrapped canvas context should not be manipulated externally\n * until the wrapping `GraphicsContext` object is disposed.\n */\nexport\nclass GraphicsContext implements IDisposable {\n  /**\n   * Create a new graphics context object.\n   *\n   * @param context - The 2D canvas rendering context to wrap.\n   */\n  constructor(context: CanvasRenderingContext2D) {\n    this._context = context;\n    this._state = Private.State.create(context);\n  }\n\n  dispose(): void {\n    // Bail if the gc is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Mark the gc as disposed.\n    this._disposed = true;\n\n    // Pop any unrestored saves.\n    while (this._state.next) {\n      this._state = this._state.next;\n      this._context.restore();\n    }\n  }\n\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  get fillStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.fillStyle;\n  }\n\n  set fillStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.fillStyle !== value) {\n      this._state.fillStyle = value;\n      this._context.fillStyle = value;\n    }\n  }\n\n  get strokeStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.strokeStyle;\n  }\n\n  set strokeStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.strokeStyle !== value) {\n      this._state.strokeStyle = value;\n      this._context.strokeStyle = value;\n    }\n  }\n\n  get font(): string {\n    return this._context.font;\n  }\n\n  set font(value: string) {\n    if (this._state.font !== value) {\n      this._state.font = value;\n      this._context.font = value;\n    }\n  }\n\n  get textAlign(): CanvasTextAlign {\n    return this._context.textAlign;\n  }\n\n  set textAlign(value: CanvasTextAlign) {\n    if (this._state.textAlign !== value) {\n      this._state.textAlign = value;\n      this._context.textAlign = value;\n    }\n  }\n\n  get textBaseline(): CanvasTextBaseline {\n    return this._context.textBaseline;\n  }\n\n  set textBaseline(value: CanvasTextBaseline) {\n    if (this._state.textBaseline !== value) {\n      this._state.textBaseline = value;\n      this._context.textBaseline = value;\n    }\n  }\n\n  get lineCap(): CanvasLineCap {\n    return this._context.lineCap;\n  }\n\n  set lineCap(value: CanvasLineCap) {\n    if (this._state.lineCap !== value) {\n      this._state.lineCap = value;\n      this._context.lineCap = value;\n    }\n  }\n\n  get lineDashOffset(): number {\n    return this._context.lineDashOffset;\n  }\n\n  set lineDashOffset(value: number) {\n    if (this._state.lineDashOffset !== value) {\n      this._state.lineDashOffset = value;\n      this._context.lineDashOffset = value;\n    }\n  }\n\n  get lineJoin(): CanvasLineJoin {\n    return this._context.lineJoin;\n  }\n\n  set lineJoin(value: CanvasLineJoin) {\n    if (this._state.lineJoin !== value) {\n      this._state.lineJoin = value;\n      this._context.lineJoin = value;\n    }\n  }\n\n  get lineWidth(): number {\n    return this._context.lineWidth;\n  }\n\n  set lineWidth(value: number) {\n    if (this._state.lineWidth !== value) {\n      this._state.lineWidth = value;\n      this._context.lineWidth = value;\n    }\n  }\n\n  get miterLimit(): number {\n    return this._context.miterLimit;\n  }\n\n  set miterLimit(value: number) {\n    if (this._state.miterLimit !== value) {\n      this._state.miterLimit = value;\n      this._context.miterLimit = value;\n    }\n  }\n\n  get shadowBlur(): number {\n    return this._context.shadowBlur;\n  }\n\n  set shadowBlur(value: number) {\n    if (this._state.shadowBlur !== value) {\n      this._state.shadowBlur = value;\n      this._context.shadowBlur = value;\n    }\n  }\n\n  get shadowColor(): string {\n    return this._context.shadowColor;\n  }\n\n  set shadowColor(value: string) {\n    if (this._state.shadowColor !== value) {\n      this._state.shadowColor = value;\n      this._context.shadowColor = value;\n    }\n  }\n\n  get shadowOffsetX(): number {\n    return this._context.shadowOffsetX;\n  }\n\n  set shadowOffsetX(value: number) {\n    if (this._state.shadowOffsetX !== value) {\n      this._state.shadowOffsetX = value;\n      this._context.shadowOffsetX = value;\n    }\n  }\n\n  get shadowOffsetY(): number {\n    return this._context.shadowOffsetY;\n  }\n\n  set shadowOffsetY(value: number) {\n    if (this._state.shadowOffsetY !== value) {\n      this._state.shadowOffsetY = value;\n      this._context.shadowOffsetY = value;\n    }\n  }\n\n  get imageSmoothingEnabled(): boolean {\n    return this._context.imageSmoothingEnabled;\n  }\n\n  set imageSmoothingEnabled(value: boolean) {\n    if (this._state.imageSmoothingEnabled !== value) {\n      this._state.imageSmoothingEnabled = value;\n      this._context.imageSmoothingEnabled = value;\n    }\n  }\n\n  get globalAlpha(): number {\n    return this._context.globalAlpha;\n  }\n\n  set globalAlpha(value: number) {\n    if (this._state.globalAlpha !== value) {\n      this._state.globalAlpha = value;\n      this._context.globalAlpha = value;\n    }\n  }\n\n  get globalCompositeOperation(): string {\n    return this._context.globalCompositeOperation;\n  }\n\n  set globalCompositeOperation(value: string) {\n    if (this._state.globalCompositeOperation !== value) {\n      this._state.globalCompositeOperation = value;\n      this._context.globalCompositeOperation = value;\n    }\n  }\n\n  getLineDash(): number[] {\n    return this._context.getLineDash();\n  }\n\n  setLineDash(segments: number[]): void {\n    this._context.setLineDash(segments);\n  }\n\n  rotate(angle: number): void {\n    this._context.rotate(angle);\n  }\n\n  scale(x: number, y: number): void {\n    this._context.scale(x, y);\n  }\n\n  transform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void {\n    this._context.transform(m11, m12, m21, m22, dx, dy);\n  }\n\n  translate(x: number, y: number): void {\n    this._context.translate(x, y);\n  }\n\n  setTransform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void {\n    this._context.setTransform(m11, m12, m21, m22, dx, dy);\n  }\n\n  save(): void {\n    // Clone an push the current state to the stack.\n    this._state = Private.State.push(this._state);\n\n    // Save the wrapped context state.\n    this._context.save();\n  }\n\n  restore(): void {\n    // Bail if there is no state to restore.\n    if (!this._state.next) {\n      return;\n    }\n\n    // Pop the saved state from the stack.\n    this._state = Private.State.pop(this._state);\n\n    // Restore the wrapped context state.\n    this._context.restore();\n  }\n\n  beginPath(): void {\n    return this._context.beginPath();\n  }\n\n  closePath(): void {\n    this._context.closePath();\n  }\n\n  isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean {\n    let result: boolean;\n    if (arguments.length === 2) {\n      result = this._context.isPointInPath(x, y);\n    } else {\n      result = this._context.isPointInPath(x, y, fillRule);\n    }\n    return result;\n  }\n\n  arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void {\n    if (arguments.length === 5) {\n      this._context.arc(x, y, radius, startAngle, endAngle);\n    } else {\n      this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n  }\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void {\n    this._context.arcTo(x1, y1, x2, y2, radius);\n  }\n\n  bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void {\n    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n\n  ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void {\n    if (arguments.length === 7) {\n      this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);\n    } else {\n      this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\n    }\n  }\n\n  lineTo(x: number, y: number): void {\n    this._context.lineTo(x, y);\n  }\n\n  moveTo(x: number, y: number): void {\n    this._context.moveTo(x, y);\n  }\n\n  quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void {\n    this._context.quadraticCurveTo(cpx, cpy, x, y);\n  }\n\n  rect(x: number, y: number, w: number, h: number): void {\n    this._context.rect(x, y, w, h);\n  }\n\n  clip(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.clip();\n    } else {\n      this._context.clip(fillRule);\n    }\n  }\n\n  fill(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.fill();\n    } else {\n      this._context.fill(fillRule);\n    }\n  }\n\n  stroke(): void {\n    this._context.stroke();\n  }\n\n  clearRect(x: number, y: number, w: number, h: number): void {\n    return this._context.clearRect(x, y, w, h);\n  }\n\n  fillRect(x: number, y: number, w: number, h: number): void {\n    this._context.fillRect(x, y, w, h);\n  }\n\n  fillText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.fillText(text, x, y);\n    } else {\n      this._context.fillText(text, x, y, maxWidth);\n    }\n  }\n\n  strokeRect(x: number, y: number, w: number, h: number): void {\n    this._context.strokeRect(x, y, w, h);\n  }\n\n  strokeText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.strokeText(text, x, y);\n    } else {\n      this._context.strokeText(text, x, y, maxWidth);\n    }\n  }\n\n  measureText(text: string): TextMetrics {\n    return this._context.measureText(text);\n  }\n\n  createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient {\n    return this._context.createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient {\n    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  createPattern(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition: string): CanvasPattern | null {\n    return this._context.createPattern(image, repetition);\n  }\n\n  createImageData(imageData: ImageData): ImageData;\n  createImageData(sw: number, sh: number): ImageData;\n  createImageData() {\n    return this._context.createImageData.apply(this._context, arguments);\n  }\n\n  getImageData(sx: number, sy: number, sw: number, sh: number): ImageData {\n    return this._context.getImageData(sx, sy, sw, sh);\n  }\n\n  putImageData(imagedata: ImageData, dx: number, dy: number): void\n  putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void\n  putImageData(): void {\n    this._context.putImageData.apply(this._context, arguments);\n  }\n\n  drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number): void;\n  drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number, dstW: number, dstH: number): void;\n  drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, srcX: number, srcY: number, srcW: number, srcH: number, dstX: number, dstY: number, dstW: number, dstH: number): void;\n  drawImage(): void {\n    this._context.drawImage.apply(this._context, arguments);\n  }\n\n  drawFocusIfNeeded(element: Element): void {\n    this._context.drawFocusIfNeeded(element);\n  }\n\n  private _disposed = false;\n  private _state: Private.State;\n  private _context: CanvasRenderingContext2D;\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The index of next valid pool object.\n   */\n  let pi = -1;\n\n  /**\n   * A state object allocation pool.\n   */\n  const pool: State[] = [];\n\n  /**\n   * An object which holds the state for a gc.\n   */\n  export\n  class State {\n    /**\n     * Create a gc state object from a 2D canvas context.\n     */\n    static create(context: CanvasRenderingContext2D): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = null;\n      state.fillStyle = context.fillStyle;\n      state.font = context.font;\n      state.globalAlpha = context.globalAlpha;\n      state.globalCompositeOperation = context.globalCompositeOperation;\n      state.imageSmoothingEnabled = context.imageSmoothingEnabled;\n      state.lineCap = context.lineCap;\n      state.lineDashOffset = context.lineDashOffset;\n      state.lineJoin = context.lineJoin;\n      state.lineWidth = context.lineWidth;\n      state.miterLimit = context.miterLimit;\n      state.shadowBlur = context.shadowBlur;\n      state.shadowColor = context.shadowColor;\n      state.shadowOffsetX = context.shadowOffsetX;\n      state.shadowOffsetY = context.shadowOffsetY;\n      state.strokeStyle = context.strokeStyle;\n      state.textAlign = context.textAlign;\n      state.textBaseline = context.textBaseline;\n      return state;\n    }\n\n    /**\n     * Clone an existing gc state object and add it to the state stack.\n     */\n    static push(other: State): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = other;\n      state.fillStyle = other.fillStyle;\n      state.font = other.font;\n      state.globalAlpha = other.globalAlpha;\n      state.globalCompositeOperation = other.globalCompositeOperation;\n      state.imageSmoothingEnabled = other.imageSmoothingEnabled;\n      state.lineCap = other.lineCap;\n      state.lineDashOffset = other.lineDashOffset;\n      state.lineJoin = other.lineJoin;\n      state.lineWidth = other.lineWidth;\n      state.miterLimit = other.miterLimit;\n      state.shadowBlur = other.shadowBlur;\n      state.shadowColor = other.shadowColor;\n      state.shadowOffsetX = other.shadowOffsetX;\n      state.shadowOffsetY = other.shadowOffsetY;\n      state.strokeStyle = other.strokeStyle;\n      state.textAlign = other.textAlign;\n      state.textBaseline = other.textBaseline;\n      return state;\n    }\n\n    /**\n     * Pop the next state object and return the current to the pool\n     */\n    static pop(state: State): State {\n      state.fillStyle = '';\n      state.strokeStyle = '';\n      pool[++pi] = state;\n      return state.next!;\n    }\n\n    next: State | null;\n\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    font: string;\n    globalAlpha: number;\n    globalCompositeOperation: string;\n    imageSmoothingEnabled: boolean;\n    lineCap: string;\n    lineDashOffset: number;\n    lineJoin: string;\n    lineWidth: number;\n    miterLimit: number;\n    shadowBlur: number;\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n    textAlign: string;\n    textBaseline: string;\n\n    private constructor() { }\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  CellRenderer\n} from './cellrenderer';\n\nimport {\n  GraphicsContext\n} from './graphicscontext';\n\n\n/**\n * A cell renderer which renders data values as text.\n */\nexport\nclass TextRenderer extends CellRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: TextRenderer.IOptions = {}) {\n    super();\n    this.font = options.font || '12px sans-serif';\n    this.textColor = options.textColor || '#000000';\n    this.backgroundColor = options.backgroundColor || '';\n    this.verticalAlignment = options.verticalAlignment || 'center';\n    this.horizontalAlignment = options.horizontalAlignment || 'left';\n    this.format = options.format || TextRenderer.formatGeneric();\n    this.elideDirection = options.elideDirection || 'right';\n  }\n\n  /**\n   * The CSS shorthand font for drawing the text.\n   */\n  readonly font: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for drawing the text.\n   */\n  readonly textColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for the cell background.\n   */\n  readonly backgroundColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The vertical alignment for the cell text.\n   */\n  readonly verticalAlignment: CellRenderer.ConfigOption<TextRenderer.VerticalAlignment>;\n\n  /**\n   * The horizontal alignment for the cell text.\n   */\n  readonly horizontalAlignment: CellRenderer.ConfigOption<TextRenderer.HorizontalAlignment>;\n\n  /**\n   * The format function for the cell value.\n   */\n  readonly format: TextRenderer.FormatFunc;\n\n  /**\n   * Which side to draw the ellipsis.\n   */\n  readonly elideDirection: CellRenderer.ConfigOption<TextRenderer.ElideDirection>;\n\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    this.drawBackground(gc, config);\n    this.drawText(gc, config);\n  }\n\n  /**\n   * Draw the background for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawBackground(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the background color for the cell.\n    let color = CellRenderer.resolveOption(this.backgroundColor, config);\n\n    // Bail if there is no background color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Fill the cell with the background color.\n    gc.fillStyle = color;\n    gc.fillRect(config.x, config.y, config.width, config.height);\n  }\n\n  /**\n   * Draw the text for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawText(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the font for the cell.\n    let font = CellRenderer.resolveOption(this.font, config);\n\n    // Bail if there is no font to draw.\n    if (!font) {\n      return;\n    }\n\n    // Resolve the text color for the cell.\n    let color = CellRenderer.resolveOption(this.textColor, config);\n\n    // Bail if there is no text color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Format the cell value to text.\n    let format = this.format;\n    let text = format(config);\n\n    // Bail if there is no text to draw.\n    if (!text) {\n      return;\n    }\n\n    // Resolve the vertical and horizontal alignment.\n    let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n    let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n\n    // Resolve the elision direction\n    let elideDirection = CellRenderer.resolveOption(this.elideDirection, config);\n\n    // Compute the padded text box height for the specified alignment.\n    let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n\n    // Bail if the text box has no effective size.\n    if (boxHeight <= 0) {\n      return;\n    }\n\n    // Compute the text height for the gc font.\n    let textHeight = TextRenderer.measureFontHeight(font);\n\n    // Set up the text position variables.\n    let textX: number;\n    let textY: number;\n    let boxWidth: number;\n\n    // Compute the Y position for the text.\n    switch (vAlign) {\n    case 'top':\n      textY = config.y + 2 + textHeight;\n      break;\n    case 'center':\n      textY = config.y + config.height / 2 + textHeight / 2;\n      break;\n    case 'bottom':\n      textY = config.y + config.height - 2;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Compute the X position for the text.\n    switch (hAlign) {\n    case 'left':\n      textX = config.x + 8;\n      boxWidth = config.width - 14;\n      break;\n    case 'center':\n      textX = config.x + config.width / 2;\n      boxWidth = config.width;\n      break;\n    case 'right':\n      textX = config.x + config.width - 8;\n      boxWidth = config.width - 14;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Clip the cell if the text is taller than the text box height.\n    if (textHeight > boxHeight) {\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n    }\n\n    // Set the gc state.\n    gc.font = font;\n    gc.fillStyle = color;\n    gc.textAlign = hAlign;\n    gc.textBaseline = 'bottom';\n\n    // Elide text that is too long\n    let elide = '\\u2026';\n    let textWidth = gc.measureText(text).width;\n\n    // Compute elided text\n    if (elideDirection === 'right') {\n      while ((textWidth > boxWidth) && (text.length > 1)) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = text.substring(0, (text.length / 2) + 1) + elide;\n        } else {\n          // Otherwise incrementally remove the last character\n          text = text.substring(0, text.length - 2) + elide;\n        }\n        textWidth = gc.measureText(text).width;\n      } \n    } else {\n      while ((textWidth > boxWidth) && (text.length > 1)) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = elide + text.substring((text.length / 2));\n        } else {\n          // Otherwise incrementally remove the last character\n          text = elide + text.substring(2);\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    }\n\n    // Draw the text for the cell.\n    gc.fillText(text, textX, textY);\n  }\n}\n\n\n/**\n * The namespace for the `TextRenderer` class statics.\n */\nexport\nnamespace TextRenderer {\n  /**\n   * A type alias for the supported vertical alignment modes.\n   */\n  export\n  type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * A type alias for the supported horizontal alignment modes.\n   */\n  export\n  type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the supported ellipsis sides.\n   */\n  export\n  type ElideDirection = 'left' | 'right';\n\n  /**\n   * An options object for initializing a text renderer.\n   */\n  export\n  interface IOptions {\n    /**\n     * The font for drawing the cell text.\n     *\n     * The default is `'12px sans-serif'`.\n     */\n    font?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The color for the drawing the cell text.\n     *\n     * The default `'#000000'`.\n     */\n    textColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The background color for the cells.\n     *\n     * The default is `''`.\n     */\n    backgroundColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The vertical alignment for the cell text.\n     *\n     * The default is `'center'`.\n     */\n    verticalAlignment?: CellRenderer.ConfigOption<VerticalAlignment>;\n\n    /**\n     * The horizontal alignment for the cell text.\n     *\n     * The default is `'left'`.\n     */\n    horizontalAlignment?: CellRenderer.ConfigOption<HorizontalAlignment>;\n\n    /**\n     * The format function for the renderer.\n     *\n     * The default is `TextRenderer.formatGeneric()`.\n     */\n    format?: FormatFunc;\n\n    /**\n     * The ellipsis direction for the cell text.\n     *\n     * The default is `'right'`.\n     */\n    elideDirection?: CellRenderer.ConfigOption<ElideDirection>;\n\n  }\n\n  /**\n   * A type alias for a format function.\n   */\n  export\n  type FormatFunc = CellRenderer.ConfigFunc<string>;\n\n  /**\n   * Create a generic text format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new generic text format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `String()` to coerce any value\n   * to a string.\n   */\n  export\n  function formatGeneric(options: formatGeneric.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return String(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatGeneric` function statics.\n   */\n  export\n  namespace formatGeneric {\n    /**\n     * The options for creating a generic format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a fixed decimal format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new fixed decimal format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toFixed()` to\n   * coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export\n  function formatFixed(options: formatFixed.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toFixed(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatFixed` function statics.\n   */\n  export\n  namespace formatFixed {\n    /**\n     * The options for creating a fixed format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a significant figure format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new significant figure format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toPrecision()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export\n  function formatPrecision(options: formatPrecision.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toPrecision(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatPrecision` function statics.\n   */\n  export\n  namespace formatPrecision {\n    /**\n     * The options for creating a precision format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The number of significant figures to include in the value.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a scientific notation format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new scientific notation format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toExponential()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export\n  function formatExponential(options: formatExponential.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toExponential(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatExponential` function statics.\n   */\n  export\n  namespace formatExponential {\n    /**\n     * The options for creating an exponential format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international number format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international number format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.NumberFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) number formatter.\n   */\n  export\n  function formatIntlNumber(options: formatIntlNumber.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    let nft = new Intl.NumberFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return nft.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlNumber` function statics.\n   */\n  export\n  namespace formatIntlNumber {\n    /**\n     * The options for creating an intl number format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The locales to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.NumberFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a date format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new date format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toDateString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatDate(options: formatDate.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toDateString();\n      }\n      return (new Date(value)).toDateString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatDate` function statics.\n   */\n  export\n  namespace formatDate {\n    /**\n     * The options for creating a date format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a time format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new time format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toTimeString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatTime(options: formatTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toTimeString();\n      }\n      return (new Date(value)).toTimeString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatTime` function statics.\n   */\n  export\n  namespace formatTime {\n    /**\n     * The options for creating a time format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an ISO datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new ISO datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toISOString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatISODateTime(options: formatISODateTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n      return (new Date(value)).toISOString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatISODateTime` function statics.\n   */\n  export\n  namespace formatISODateTime {\n    /**\n     * The options for creating an ISO datetime format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a UTC datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new UTC datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toUTCString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatUTCDateTime(options: formatUTCDateTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toUTCString();\n      }\n      return (new Date(value)).toUTCString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatUTCDateTime` function statics.\n   */\n  export\n  namespace formatUTCDateTime {\n    /**\n     * The options for creating a UTC datetime format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international datetime format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.DateTimeFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) datetime formatter.\n   */\n  export\n  function formatIntlDateTime(options: formatIntlDateTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    let dtf = new Intl.DateTimeFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return dtf.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlDateTime` function statics.\n   */\n  export\n  namespace formatIntlDateTime {\n    /**\n     * The options for creating an intl datetime format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The locales to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.DateTimeFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Measure the height of a font.\n   *\n   * @param font - The CSS font string of interest.\n   *\n   * @returns The height of the font bounding box.\n   *\n   * #### Notes\n   * This function uses a temporary DOM node to measure the text box\n   * height for the specified font. The first call for a given font\n   * will incur a DOM reflow, but the return value is cached, so any\n   * subsequent call for the same font will return the cached value.\n   */\n  export\n  function measureFontHeight(font: string): number {\n    // Look up the cached font height.\n    let height = Private.fontHeightCache[font];\n\n    // Return the cached font height if it exists.\n    if (height !== undefined) {\n      return height;\n    }\n\n    // Normalize the font.\n    Private.fontMeasurementGC.font = font;\n    let normFont = Private.fontMeasurementGC.font;\n\n    // Set the font on the measurement node.\n    Private.fontMeasurementNode.style.font = normFont;\n\n    // Add the measurement node to the document.\n    document.body.appendChild(Private.fontMeasurementNode);\n\n    // Measure the node height.\n    height = Private.fontMeasurementNode.offsetHeight;\n\n    // Remove the measurement node from the document.\n    document.body.removeChild(Private.fontMeasurementNode);\n\n    // Cache the measured height for the font and norm font.\n    Private.fontHeightCache[font] = height;\n    Private.fontHeightCache[normFont] = height;\n\n    // Return the measured height.\n    return height;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A cache of measured font heights.\n   */\n  export\n  const fontHeightCache: { [font: string]: number } = Object.create(null);\n\n  /**\n   * The DOM node used for font height measurement.\n   */\n  export\n  const fontMeasurementNode = (() => {\n    let node = document.createElement('div');\n    node.style.position = 'absolute';\n    node.style.top = '-99999px';\n    node.style.left = '-99999px';\n    node.style.visibility = 'hidden';\n    node.textContent = 'M';\n    return node;\n  })();\n\n  /**\n   * The GC used for font measurement.\n   */\n  export\n  const fontMeasurementGC = (() => {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas.getContext('2d')!;\n  })();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ArrayExt\n} from '@lumino/algorithm';\n\n\n/**\n * An object which manages a collection of variable sized sections.\n *\n * #### Notes\n * This class is an implementation detail. It is designed to manage\n * the variable row and column sizes for a data grid. User code will\n * not interact with this class directly.\n */\nexport\nclass SectionList {\n  /**\n   * Construct a new section list.\n   *\n   * @param options - The options for initializing the list.\n   */\n  constructor(options: SectionList.IOptions) {\n    this._minimumSize = options.minimumSize || 2;\n    this._defaultSize = Math.max(this._minimumSize, Math.floor(options.defaultSize));\n  }\n\n  /**\n   * The total size of all sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * The total number of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Get the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get minimumSize(): number {\n    return this._minimumSize;\n  }\n\n  /**\n   * Set the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set minimumSize(value: number) {\n    // Normalize the value.\n    value = Math.max(2, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._minimumSize === value) {\n      return;\n    }\n\n    // Update the internal minimum size.\n    this._minimumSize = value;\n\n    // Update default size if larger than minimum size\n    if (value > this._defaultSize) {\n      this.defaultSize = value;\n    }\n  }\n\n  /**\n   * Get the default size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get defaultSize(): number {\n    return this._defaultSize;\n  }\n\n  /**\n   * Set the default size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set defaultSize(value: number) {\n    // Normalize the value.\n    value = Math.max(this._minimumSize, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._defaultSize === value) {\n      return;\n    }\n\n    // Compute the delta default size.\n    let delta = value - this._defaultSize;\n\n    // Update the internal default size.\n    this._defaultSize = value;\n\n    // Update the length.\n    this._length += delta * (this._count - this._sections.length);\n\n    // Bail early if there are no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Recompute the offsets of the modified sections.\n    for (let i = 0, n = this._sections.length; i < n; ++i) {\n      // Look up the previous and current modified sections.\n      let prev = this._sections[i - 1];\n      let curr = this._sections[i];\n\n      // Adjust the offset for the current section.\n      if (prev) {\n        let count = curr.index - prev.index - 1;\n        curr.offset = prev.offset + prev.size + count * value;\n      } else {\n        curr.offset = curr.index * value;\n      }\n    }\n  }\n\n  /**\n   * Clamp a size to the minimum section size\n   *\n   * @param size - The size to clamp.\n   *\n   * @returns The size or the section minimum size, whichever is larger\n   */\n  clampSize(size: number): number {\n    return Math.max(this._minimumSize, Math.floor(size));\n  }\n\n  /**\n   * Find the index of the section which covers the given offset.\n   *\n   * @param offset - The offset of the section of interest.\n   *\n   * @returns The index of the section which covers the given offset,\n   *   or `-1` if the offset is out of range.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  indexOf(offset: number): number {\n    // Bail early if the offset is out of range.\n    if (offset < 0 || offset >= this._length || this._count === 0) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Find the modified section for the given offset.\n    let i = ArrayExt.lowerBound(this._sections, offset, Private.offsetCmp);\n\n    // Return the index of an exact match.\n    if (i < this._sections.length && this._sections[i].offset <= offset) {\n      return this._sections[i].index;\n    }\n\n    // Handle the case of no modified sections before the offset.\n    if (i === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Compute the index from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = offset - (section.offset + section.size);\n    return section.index + Math.floor(span / this._defaultSize) + 1;\n  }\n\n  /**\n   * Find the offset of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The offset of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  offsetOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index - 1;\n    return section.offset + section.size + span * this._defaultSize;\n  }\n\n  /**\n   * Find the extent of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The extent of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  extentOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset + this._sections[i].size - 1;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index;\n    return section.offset + section.size + span * this._defaultSize - 1;\n  }\n\n  /**\n   * Find the size of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The size of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  sizeOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the size of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].size;\n    }\n\n    // Return the default size for all other cases.\n    return this._defaultSize;\n  }\n\n  /**\n   * Resize a section in the list.\n   *\n   * @param index - The index of the section to resize. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param size - The new size of the section. This value will be\n   *   clamped to an integer `>= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  resize(index: number, size: number): void {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return;\n    }\n\n    // Clamp the size to an integer >= minimum size.\n    size = Math.max(this._minimumSize, Math.floor(size));\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update or create the modified section as needed.\n    let delta: number;\n    if (i < this._sections.length && this._sections[i].index === index) {\n      let section = this._sections[i];\n      delta = size - section.size;\n      section.size = size;\n    } else if (i === 0) {\n      let offset = index * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    } else {\n      let section = this._sections[i - 1];\n      let span = index - section.index - 1;\n      let offset = section.offset + section.size + span * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    }\n\n    // Adjust the length.\n    this._length += delta;\n\n    // Update all modified sections after the resized section.\n    for (let j = i + 1, n = this._sections.length; j < n; ++j) {\n      this._sections[j].offset += delta;\n    }\n  }\n\n  /**\n   * Insert sections into the list.\n   *\n   * @param index - The index at which to insert the sections. This\n   *   value will be clamped to the bounds of the list.\n   *\n   * @param count - The number of sections to insert. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  insert(index: number, count: number): void {\n    // Bail early if there are no sections to insert.\n    if (count <= 0) {\n      return;\n    }\n\n    // Clamp the index to the bounds of the list.\n    index = Math.max(0, Math.min(index, this._count));\n\n    // Add the new sections to the totals.\n    let span = count * this._defaultSize;\n    this._count += count;\n    this._length += span;\n\n    // Bail early if there are no modified sections to update.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update all modified sections after the insert location.\n    for (let n = this._sections.length; i < n; ++i) {\n      let section = this._sections[i];\n      section.index += count;\n      section.offset += span;\n    }\n  }\n\n  /**\n   * Remove sections from the list.\n   *\n   * @param index - The index of the first section to remove. This\n   *   method is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to remove. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  remove(index: number, count: number): void {\n    // Bail early if there is nothing to remove.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Clamp the count to the bounds of the list.\n    count = Math.min(this._count - index, count);\n\n    // Handle the simple case of no modified sections to update.\n    if (this._sections.length === 0) {\n      this._count -= count;\n      this._length -= count * this._defaultSize;\n      return;\n    }\n\n    // Handle the simple case of removing all sections.\n    if (count === this._count) {\n      this._length = 0;\n      this._count = 0;\n      this._sections.length = 0;\n      return;\n    }\n\n    // Find the modified section for the start index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Find the modified section for the end index.\n    let j = ArrayExt.lowerBound(this._sections, index + count, Private.indexCmp);\n\n    // Remove the relevant modified sections.\n    let removed = this._sections.splice(i, j - i);\n\n    // Compute the total removed span.\n    let span = (count - removed.length) * this._defaultSize;\n    for (let k = 0, n = removed.length; k < n; ++k) {\n      span += removed[k].size;\n    }\n\n    // Adjust the totals.\n    this._count -= count;\n    this._length -= span;\n\n    // Update all modified sections after the removed span.\n    for (let k = i, n = this._sections.length; k < n; ++k) {\n      let section = this._sections[k];\n      section.index -= count;\n      section.offset -= span;\n    }\n  }\n\n  /**\n   * Move sections within the list.\n   *\n   * @param index - The index of the first section to move. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to move. This method is a\n   *   no-op if this value is `<= 0`.\n   *\n   * @param destination - The destination index for the first section.\n   *   This value will be clamped to the allowable range.\n   *\n   * #### Undefined Behavior\n   * An `index`, `count`, or `destination` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of moved resized sections.\n   */\n  move(index: number, count: number, destination: number): void {\n    // Bail early if there is nothing to move.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Clamp the move count to the limit.\n    count = Math.min(count, this._count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), this._count - count);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let i1 = Math.min(index, destination);\n\n    // Look up the first affected modified section.\n    let k1 = ArrayExt.lowerBound(this._sections, i1, Private.indexCmp);\n\n    // Bail early if there are no affected modified sections.\n    if (k1 === this._sections.length) {\n      return;\n    }\n\n    // Compute the last affected index.\n    let i2 = Math.max(index + count - 1, destination + count - 1);\n\n    // Look up the last affected modified section.\n    let k2 = ArrayExt.upperBound(this._sections, i2, Private.indexCmp) - 1;\n\n    // Bail early if there are no affected modified sections.\n    if (k2 < k1) {\n      return;\n    }\n\n    // Compute the pivot index.\n    let pivot = destination < index ? index : index + count;\n\n    // Compute the count for each side of the pivot.\n    let count1 = pivot - i1;\n    let count2 = i2 - pivot + 1;\n\n    // Compute the span for each side of the pivot.\n    let span1 = count1 * this._defaultSize;\n    let span2 = count2 * this._defaultSize;\n\n    // Adjust the spans for the modified sections.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        span1 += section.size - this._defaultSize;\n      } else {\n        span2 += section.size - this._defaultSize;\n      }\n    }\n\n    // Look up the pivot section.\n    let k3 = ArrayExt.lowerBound(this._sections, pivot, Private.indexCmp);\n\n    // Rotate the modified sections if needed.\n    if (k1 <= k3 && k3 <= k2) {\n      ArrayExt.rotate(this._sections, k3 - k1, k1, k2);\n    }\n\n    // Adjust the modified section indices and offsets.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        section.index += count2;\n        section.offset += span2;\n      } else {\n        section.index -= count1;\n        section.offset -= span1;\n      }\n    }\n  }\n\n  /**\n   * Reset all modified sections to the default size.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  reset(): void {\n    this._sections.length = 0;\n    this._length = this._count * this._defaultSize;\n  }\n\n  /**\n   * Remove all sections from the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  clear(): void {\n    this._count = 0;\n    this._length = 0;\n    this._sections.length = 0;\n  }\n\n  private _count = 0;\n  private _length = 0;\n  private _minimumSize: number;\n  private _defaultSize: number;\n  private _sections: Private.Section[] = [];\n}\n\n\n/**\n * The namespace for the `SectionList` class statics.\n */\nexport\nnamespace SectionList {\n  /**\n   * An options object for initializing a section list.\n   */\n  export\n  interface IOptions {\n    /**\n     * The size of new sections added to the list.\n     */\n    defaultSize: number;\n\n    /**\n     * The minimum size of the section list.\n     */\n    minimumSize?: number;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which represents a modified section.\n   */\n  export\n  type Section = {\n    /**\n     * The index of the section.\n     *\n     * This is always `>= 0`.\n     */\n    index: number;\n\n    /**\n     * The offset of the section.\n     */\n    offset: number;\n\n    /**\n     * The size of the section.\n     *\n     * This is always `>= 0`.\n     */\n    size: number;\n  };\n\n  /**\n   * A comparison function for searching by offset.\n   */\n  export\n  function offsetCmp(section: Section, offset: number): number {\n    if (offset < section.offset) {\n      return 1;\n    }\n    if (section.offset + section.size <= offset) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * A comparison function for searching by index.\n   */\n  export\n  function indexCmp(section: Section, index: number): number {\n    return section.index - index;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\nimport {\n  CellRenderer\n} from './cellrenderer';\n\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  TextRenderer\n} from './textrenderer';\n\n\n/**\n * A class which manages the mapping of cell renderers.\n */\nexport\nclass RendererMap {\n  /**\n   * Construct a new renderer map.\n   *\n   * @param values - The initial values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   */\n  constructor(values: RendererMap.Values = {}, fallback?: CellRenderer) {\n    this._values = { ...values };\n    this._fallback = fallback || new TextRenderer();\n  }\n\n  /**\n   * A signal emitted when the renderer map has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * Get the cell renderer to use for the given cell config.\n   *\n   * @param config - The cell config of interest.\n   *\n   * @returns The renderer to use for the cell.\n   */\n  get(config: CellRenderer.CellConfig): CellRenderer {\n    // Fetch the renderer from the values map.\n    let renderer = this._values[config.region];\n\n    // Execute a resolver function if necessary.\n    if (typeof renderer === 'function') {\n      try {\n        renderer = renderer(config);\n      } catch (err) {\n        renderer = undefined;\n        console.error(err);\n      }\n    }\n\n    // Return the renderer or the fallback.\n    return renderer || this._fallback;\n  }\n\n  /**\n   * Update the renderer map with new values\n   *\n   * @param values - The updated values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   *\n   * #### Notes\n   * This method always emits the `changed` signal.\n   */\n  update(values: RendererMap.Values = {}, fallback?: CellRenderer): void {\n    this._values = { ...this._values, ...values };\n    this._fallback = fallback || this._fallback;\n    this._changed.emit(undefined);\n  }\n\n  private _fallback: CellRenderer;\n  private _values: RendererMap.Values;\n  private _changed = new Signal<this, void>(this);\n}\n\n\n/**\n * The namespace for the `RendererMap` class statics.\n */\nexport\nnamespace RendererMap {\n  /**\n   * A type alias for a cell renderer resolver function.\n   */\n  export\n  type Resolver = CellRenderer.ConfigFunc<CellRenderer | undefined>;\n\n  /**\n   * A type alias for a `RendererMap` values type.\n   */\n  export\n  type Values = {\n    [R in DataModel.CellRegion]?: Resolver | CellRenderer | undefined;\n  };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n    ICellEditor,\n    CellEditor,\n    CellDataType,\n    ICellEditOptions,\n    TextCellEditor,\n    NumberCellEditor,\n    IntegerCellEditor,\n    BooleanCellEditor,\n    DateCellEditor,\n    OptionCellEditor,\n    DynamicOptionCellEditor,\n    ICellEditResponse\n} from './celleditor';\n\nimport {\n  DataModel, MutableDataModel\n} from './datamodel';\n\n/**\n * A type alias for cell editor override identifier.\n */\nexport\ntype EditorOverrideIdentifier = CellDataType | DataModel.Metadata | 'default';\n\n/**\n * An object which manages cell editing.\n */\nexport\ninterface ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(identifier: EditorOverrideIdentifier, editor: ICellEditor | Resolver): void;\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean;\n  /**\n   * Cancel editing.\n   */\n  cancel(): void;\n}\n\n/**\n * A type alias for a cell editor config function.\n *\n * This type is used to compute a value from a cell config object.\n */\nexport\ntype ConfigFunc<T> = (config: CellEditor.CellConfig) => T;\n\n/**\n * A type alias for a cell editor config option.\n *\n * A config option can be a static value or a config function.\n */\nexport\ntype ConfigOption<T> = T | ConfigFunc<T>;\n\n/**\n * A type alias for a cell editor resolver function.\n */\nexport\ntype Resolver = ConfigFunc<ICellEditor | undefined>;\n\n/**\n * Resolve a config option for a cell editor.\n *\n * @param option - The config option to resolve.\n *\n * @param config - The cell config object.\n *\n * @returns The resolved value for the option.\n */\nexport\nfunction resolveOption<T>(option: ConfigOption<T>, config: CellEditor.CellConfig): T {\n  return typeof option === 'function' ? (option as ConfigFunc<T>)(config) : option;\n}\n\n/**\n * An object which manages cell editing. It stores editor overrides,\n * decides which editor to use for a cell, makes sure there is only one editor active.\n */\nexport\nclass CellEditorController implements ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(identifier: EditorOverrideIdentifier, editor: ICellEditor | Resolver) {\n    if (typeof identifier === 'string') {\n      this._typeBasedOverrides.set(identifier, editor);\n    } else {\n      const key = this._metadataIdentifierToKey(identifier);\n      this._metadataBasedOverrides.set(key, [identifier, editor]);\n    }\n  }\n\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean {\n    const grid = cell.grid;\n\n    if (!grid.editable) {\n      console.error('Grid cannot be edited!');\n      return false;\n    }\n\n    this.cancel();\n\n    this._cell = cell;\n\n    options = options || {};\n    options.onCommit = options.onCommit || this._onCommit.bind(this);\n    options.onCancel = options.onCancel || this._onCancel.bind(this);\n\n    // if an editor is passed in with options, then use it for editing\n    if (options.editor) {\n      this._editor = options.editor;\n      options.editor.edit(cell, options);\n      return true;\n    }\n\n    // choose an editor based on overrides / cell data type\n    const editor = this._getEditor(cell);\n    if (editor) {\n      this._editor = editor;\n      editor.edit(cell, options);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cancel editing.\n   */\n  cancel(): void {\n    if (this._editor) {\n      this._editor.cancel();\n      this._editor = null;\n    }\n\n    this._cell = null;\n  }\n\n  private _onCommit(response: ICellEditResponse): void {\n    const cell = this._cell;\n\n    if (!cell) {\n      return;\n    }\n\n    const grid = cell.grid;\n    const dataModel = grid.dataModel as MutableDataModel;\n    dataModel.setData('body', cell.row, cell.column, response.value);\n    grid.viewport.node.focus();\n    if (response.cursorMovement !== 'none') {\n      grid.moveCursor(response.cursorMovement);\n      grid.scrollToCursor();\n    }\n  }\n\n  private _onCancel(): void {\n    if (!this._cell) {\n      return;\n    }\n\n    this._cell.grid.viewport.node.focus();\n  }\n\n  private _getDataTypeKey(cell: CellEditor.CellConfig): string {\n    const metadata = cell.grid.dataModel ? cell.grid.dataModel.metadata('body', cell.row, cell.column) : null;\n\n    if (!metadata) {\n      return 'default';\n    }\n\n    let key = '';\n\n    if (metadata) {\n      key = metadata.type;\n    }\n\n    if (metadata.constraint && metadata.constraint.enum) {\n      if (metadata.constraint.enum === 'dynamic') {\n        key += ':dynamic-option';\n      } else {\n        key += ':option';\n      }\n    }\n\n    return key;\n  }\n\n  private _objectToKey(object: any): string {\n    let str = '';\n    for (let key in object) {\n      const value = object[key];\n      if (typeof value === 'object') {\n        str += `${key}:${this._objectToKey(value)}`;\n      } else {\n        str += `[${key}:${value}]`;\n      }\n    }\n\n    return str;\n  }\n\n  private _metadataIdentifierToKey(metadata: DataModel.Metadata): string {\n    return this._objectToKey(metadata);\n  }\n\n  private _metadataMatchesIdentifier(metadata: DataModel.Metadata, identifier: DataModel.Metadata): boolean {\n    for (let key in identifier) {\n      if (!metadata.hasOwnProperty(key)) {\n        return false;\n      }\n\n      const identifierValue = identifier[key];\n      const metadataValue = metadata[key];\n      if (typeof identifierValue === 'object') {\n        if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {\n          return false;\n        }\n      } else if (metadataValue !== identifierValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _getMetadataBasedEditor(cell: CellEditor.CellConfig): ICellEditor | undefined {\n    let editorMatched: ICellEditor | undefined;\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    if (metadata) {\n      this._metadataBasedOverrides.forEach((value) => {\n        if (!editorMatched) {\n          let [identifier, editor] = value;\n          if (this._metadataMatchesIdentifier(metadata, identifier)) {\n            editorMatched = resolveOption(editor, cell);\n          }\n        }\n      });\n    }\n\n    return editorMatched;\n  }\n\n  /**\n   * Choose the most appropriate cell editor to use based on overrides / cell data type.\n   * \n   * If no match is found in overrides or based on cell data type, and if cell has a primitive\n   * data type then TextCellEditor is used as default cell editor. If 'default' cell editor\n   * is overridden, then it is used instead of TextCellEditor for default.\n   */\n  private _getEditor(cell: CellEditor.CellConfig): ICellEditor | undefined {\n    const dtKey = this._getDataTypeKey(cell);\n\n    // find an editor based on data type based override\n    if (this._typeBasedOverrides.has(dtKey)) {\n      const editor = this._typeBasedOverrides.get(dtKey);\n      return resolveOption(editor!, cell);\n    } // find an editor based on metadata match based override\n    else if (this._metadataBasedOverrides.size > 0) {\n      const editor = this._getMetadataBasedEditor(cell);\n      if (editor) {\n        return editor;\n      }\n    }\n\n    // choose an editor based on data type\n    switch (dtKey) {\n      case 'string':\n        return new TextCellEditor();\n      case 'number':\n        return new NumberCellEditor();\n      case 'integer':\n        return new IntegerCellEditor();\n      case 'boolean':\n        return new BooleanCellEditor();\n      case 'date':\n        return new DateCellEditor();\n      case 'string:option':\n      case 'number:option':\n      case 'integer:option':\n      case 'date:option':\n      case 'array:option':\n        return new OptionCellEditor();\n      case 'string:dynamic-option':\n      case 'number:dynamic-option':\n      case 'integer:dynamic-option':\n      case 'date:dynamic-option':\n        return new DynamicOptionCellEditor();\n    }\n\n    // if an override exists for 'default', then use it\n    if (this._typeBasedOverrides.has('default')) {\n      const editor = this._typeBasedOverrides.get('default');\n      return resolveOption(editor!, cell);\n    }\n\n    // if cell has a primitive data type then use TextCellEditor\n    const data = cell.grid.dataModel!.data('body', cell.row, cell.column);\n    if (!data || typeof data !== 'object') {\n      return new TextCellEditor();\n    }\n\n    // no suitable editor found for the cell\n    return undefined;\n  }\n\n  // active cell editor\n  private _editor: ICellEditor | null = null;\n  // active cell being edited\n  private _cell: CellEditor.CellConfig | null = null;\n  // cell editor overrides based on cell data type identifier\n  private _typeBasedOverrides: Map<string, ICellEditor | Resolver> = new Map();\n  // cell editor overrides based on partial metadata match\n  private _metadataBasedOverrides: Map<string, [DataModel.Metadata, ICellEditor | Resolver]> = new Map();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  toArray\n} from '@lumino/algorithm';\n\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\nimport {\n  ClipboardExt, ElementExt, Platform\n} from '@lumino/domutils';\n\nimport {\n  ConflatableMessage, IMessageHandler, Message, MessageLoop\n} from '@lumino/messaging';\n\nimport {\n  GridLayout, ScrollBar, Widget\n} from '@lumino/widgets';\n\nimport {\n  CellRenderer\n} from './cellrenderer';\n\nimport {\n  DataModel, MutableDataModel\n} from './datamodel';\n\nimport {\n  GraphicsContext\n} from './graphicscontext';\n\nimport {\n  RendererMap\n} from './renderermap';\n\nimport {\n  SectionList\n} from './sectionlist';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  ICellEditorController,\n  CellEditorController\n} from './celleditorcontroller';\n\n\n/**\n * A widget which implements a high-performance tabular data grid.\n *\n * #### Notes\n * A data grid is implemented as a composition of child widgets. These\n * child widgets are considered an implementation detail. Manipulating\n * the child widgets of a data grid directly is undefined behavior.\n *\n * This class is not designed to be subclassed.\n */\nexport\nclass DataGrid extends Widget {\n  /**\n   * Construct a new data grid.\n   *\n   * @param options - The options for initializing the data grid.\n   */\n  constructor(options: DataGrid.IOptions = {}) {\n    super();\n    this.addClass('lm-DataGrid');\n    /* <DEPRECATED> */\n    this.addClass('p-DataGrid');\n    /* </DEPRECATED> */\n\n    // Parse the simple options.\n    this._style = options.style || DataGrid.defaultStyle;\n    this._stretchLastRow = options.stretchLastRow || false;\n    this._stretchLastColumn = options.stretchLastColumn || false;\n    this._headerVisibility = options.headerVisibility || 'all';\n    this._cellRenderers = options.cellRenderers || new RendererMap();\n    this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;\n\n    // Connect to the renderer map changed signal.\n    this._cellRenderers.changed.connect(this._onRenderersChanged, this);\n\n    // Parse the default sizes.\n    let defaultSizes = options.defaultSizes || DataGrid.defaultSizes;\n    let minimumSizes = options.minimumSizes || DataGrid.minimumSizes;\n\n    // Set up the sections lists.\n    this._rowSections = new SectionList({ defaultSize: defaultSizes.rowHeight,\n      minimumSize: minimumSizes.rowHeight });\n    this._columnSections = new SectionList({ defaultSize: defaultSizes.columnWidth,\n      minimumSize: minimumSizes.columnWidth});\n    this._rowHeaderSections = new SectionList({ defaultSize: defaultSizes.rowHeaderWidth,\n      minimumSize: minimumSizes.rowHeaderWidth});\n    this._columnHeaderSections = new SectionList({ defaultSize: defaultSizes.columnHeaderHeight,\n      minimumSize: minimumSizes.columnHeaderHeight});\n\n    // Create the canvas, buffer, and overlay objects.\n    this._canvas = Private.createCanvas();\n    this._buffer = Private.createCanvas();\n    this._overlay = Private.createCanvas();\n\n    // Get the graphics contexts for the canvases.\n    this._canvasGC = this._canvas.getContext('2d')!;\n    this._bufferGC = this._buffer.getContext('2d')!;\n    this._overlayGC = this._overlay.getContext('2d')!;\n\n    // Set up the on-screen canvas.\n    this._canvas.style.position = 'absolute';\n    this._canvas.style.top = '0px';\n    this._canvas.style.left = '0px';\n    this._canvas.style.width = '0px';\n    this._canvas.style.height = '0px';\n\n    // Set up the on-screen overlay.\n    this._overlay.style.position = 'absolute';\n    this._overlay.style.top = '0px';\n    this._overlay.style.left = '0px';\n    this._overlay.style.width = '0px';\n    this._overlay.style.height = '0px';\n\n    // Create the internal widgets for the data grid.\n    this._viewport = new Widget();\n    this._viewport.node.tabIndex = -1;\n    this._viewport.node.style.outline = 'none';\n    this._vScrollBar = new ScrollBar({ orientation: 'vertical' });\n    this._hScrollBar = new ScrollBar({ orientation: 'horizontal' });\n    this._scrollCorner = new Widget();\n\n    this._editorController = new CellEditorController();\n\n    // Add the extra class names to the child widgets.\n    this._viewport.addClass('lm-DataGrid-viewport');\n    this._vScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._hScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._scrollCorner.addClass('lm-DataGrid-scrollCorner');\n    /* <DEPRECATED> */\n    this._viewport.addClass('p-DataGrid-viewport');\n    this._vScrollBar.addClass('p-DataGrid-scrollBar');\n    this._hScrollBar.addClass('p-DataGrid-scrollBar');\n    this._scrollCorner.addClass('p-DataGrid-scrollCorner');\n    /* </DEPRECATED> */\n\n    // Add the on-screen canvas to the viewport node.\n    this._viewport.node.appendChild(this._canvas);\n\n    // Add the on-screen overlay to the viewport node.\n    this._viewport.node.appendChild(this._overlay);\n\n    // Install the message hooks.\n    MessageLoop.installMessageHook(this._viewport, this);\n    MessageLoop.installMessageHook(this._hScrollBar, this);\n    MessageLoop.installMessageHook(this._vScrollBar, this);\n\n    // Hide the scroll bars and corner from the outset.\n    this._vScrollBar.hide();\n    this._hScrollBar.hide();\n    this._scrollCorner.hide();\n\n    // Connect to the scroll bar signals.\n    this._vScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._hScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._vScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._hScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._vScrollBar.stepRequested.connect(this._onStepRequested, this);\n    this._hScrollBar.stepRequested.connect(this._onStepRequested, this);\n\n    // Set the layout cell config for the child widgets.\n    GridLayout.setCellConfig(this._viewport, { row: 0, column: 0 });\n    GridLayout.setCellConfig(this._vScrollBar, { row: 0, column: 1 });\n    GridLayout.setCellConfig(this._hScrollBar, { row: 1, column: 0 });\n    GridLayout.setCellConfig(this._scrollCorner, { row: 1, column: 1 });\n\n    // Create the layout for the data grid.\n    let layout = new GridLayout({\n      rowCount: 2,\n      columnCount: 2,\n      rowSpacing: 0,\n      columnSpacing: 0,\n      fitPolicy: 'set-no-constraint'\n    });\n\n    // Set the stretch factors for the grid.\n    layout.setRowStretch(0, 1);\n    layout.setRowStretch(1, 0);\n    layout.setColumnStretch(0, 1);\n    layout.setColumnStretch(1, 0);\n\n    // Add the child widgets to the layout.\n    layout.addWidget(this._viewport);\n    layout.addWidget(this._vScrollBar);\n    layout.addWidget(this._hScrollBar);\n    layout.addWidget(this._scrollCorner);\n\n    // Install the layout on the data grid.\n    this.layout = layout;\n  }\n\n  /**\n   * Dispose of the resources held by the widgets.\n   */\n  dispose(): void {\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Dispose of the handlers.\n    if (this._keyHandler) {\n      this._keyHandler.dispose();\n    }\n    if (this._mouseHandler) {\n      this._mouseHandler.dispose();\n    }\n    this._keyHandler = null;\n    this._mouseHandler = null;\n\n    // Clear the models.\n    this._dataModel = null;\n    this._selectionModel = null;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Dispose of the base class.\n    super.dispose();\n  }\n\n  /**\n   * Get the data model for the data grid.\n   */\n  get dataModel(): DataModel | null {\n    return this._dataModel;\n  }\n\n  /**\n   * Set the data model for the data grid.\n   *\n   * #### Notes\n   * This will automatically remove the current selection model.\n   */\n  set dataModel(value: DataModel | null) {\n    // Do nothing if the model does not change.\n    if (this._dataModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Clear the selection model.\n    this.selectionModel = null;\n\n    // Disconnect the change handler from the old model.\n    if (this._dataModel) {\n      this._dataModel.changed.disconnect(this._onDataModelChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onDataModelChanged, this);\n    }\n\n    // Update the internal model reference.\n    this._dataModel = value;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Populate the section lists.\n    if (value) {\n      this._rowSections.insert(0, value.rowCount('body'));\n      this._columnSections.insert(0, value.columnCount('body'));\n      this._rowHeaderSections.insert(0, value.columnCount('row-header'));\n      this._columnHeaderSections.insert(0, value.rowCount('column-header'));\n    }\n\n    // Reset the scroll position.\n    this._scrollX = 0;\n    this._scrollY = 0;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the selection model for the data grid.\n   */\n  get selectionModel(): SelectionModel | null {\n    return this._selectionModel;\n  }\n\n  /**\n   * Set the selection model for the data grid.\n   */\n  set selectionModel(value: SelectionModel | null) {\n    // Do nothing if the selection model does not change.\n    if (this._selectionModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Ensure the data models are a match.\n    if (value && value.dataModel !== this._dataModel) {\n      throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');\n    }\n\n    // Disconnect the change handler from the old model.\n    if (this._selectionModel) {\n      this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onSelectionsChanged, this);\n    }\n\n    // Update the internal selection model reference.\n    this._selectionModel = value;\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the key handler for the data grid.\n   */\n  get keyHandler(): DataGrid.IKeyHandler | null {\n    return this._keyHandler;\n  }\n\n  /**\n   * Set the key handler for the data grid.\n   */\n  set keyHandler(value: DataGrid.IKeyHandler | null) {\n    this._keyHandler = value;\n  }\n\n  /**\n   * Get the mouse handler for the data grid.\n   */\n  get mouseHandler(): DataGrid.IMouseHandler | null {\n    return this._mouseHandler;\n  }\n\n  /**\n   * Set the mouse handler for the data grid.\n   */\n  set mouseHandler(value: DataGrid.IMouseHandler | null) {\n    // Bail early if the mouse handler does not change.\n    if (this._mouseHandler === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Update the internal mouse handler.\n    this._mouseHandler = value;\n  }\n\n  /**\n   * Get the style for the data grid.\n   */\n  get style(): DataGrid.Style {\n    return this._style;\n  }\n\n  /**\n   * Set the style for the data grid.\n   */\n  set style(value: DataGrid.Style) {\n    // Bail if the style does not change.\n    if (this._style === value) {\n      return;\n    }\n\n    // Update the internal style.\n    this._style = { ...value };\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the cell renderer map for the data grid.\n   */\n  get cellRenderers(): RendererMap {\n    return this._cellRenderers;\n  }\n\n  /**\n   * Set the cell renderer map for the data grid.\n   */\n  set cellRenderers(value: RendererMap) {\n    // Bail if the renderer map does not change.\n    if (this._cellRenderers === value) {\n      return;\n    }\n\n    // Disconnect the old map.\n    this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);\n\n    // Connect the new map.\n    value.changed.connect(this._onRenderersChanged, this);\n\n    // Update the internal renderer map.\n    this._cellRenderers = value;\n\n    // Schedule a repaint of the grid content.\n    this.repaintContent();\n  }\n\n  /**\n   * Get the header visibility for the data grid.\n   */\n  get headerVisibility(): DataGrid.HeaderVisibility {\n    return this._headerVisibility;\n  }\n\n  /**\n   * Set the header visibility for the data grid.\n   */\n  set headerVisibility(value: DataGrid.HeaderVisibility) {\n    // Bail if the visibility does not change.\n    if (this._headerVisibility === value) {\n      return;\n    }\n\n    // Update the internal visibility.\n    this._headerVisibility = value;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the default sizes for the various sections of the data grid.\n   */\n  get defaultSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.defaultSize;\n    let columnWidth = this._columnSections.defaultSize;\n    let rowHeaderWidth = this._rowHeaderSections.defaultSize;\n    let columnHeaderHeight = this._columnHeaderSections.defaultSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the default sizes for the various sections of the data grid.\n   */\n  set defaultSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.defaultSize = value.rowHeight;\n    this._columnSections.defaultSize = value.columnWidth;\n    this._rowHeaderSections.defaultSize = value.rowHeaderWidth;\n    this._columnHeaderSections.defaultSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the minimum sizes for the various sections of the data grid.\n   */\n  get minimumSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.minimumSize;\n    let columnWidth = this._columnSections.minimumSize;\n    let rowHeaderWidth = this._rowHeaderSections.minimumSize;\n    let columnHeaderHeight = this._columnHeaderSections.minimumSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the minimum sizes for the various sections of the data grid.\n   */\n  set minimumSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.minimumSize = value.rowHeight;\n    this._columnSections.minimumSize = value.columnWidth;\n    this._rowHeaderSections.minimumSize = value.rowHeaderWidth;\n    this._columnHeaderSections.minimumSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the copy configuration for the data grid.\n   */\n  get copyConfig(): DataGrid.CopyConfig {\n    return this._copyConfig;\n  }\n\n  /**\n   * Set the copy configuration for the data grid.\n   */\n  set copyConfig(value: DataGrid.CopyConfig) {\n    this._copyConfig = value;\n  }\n\n  /**\n   * Get whether the last row is stretched.\n   */\n  get stretchLastRow(): boolean {\n    return this._stretchLastRow;\n  }\n\n  /**\n   * Set whether the last row is stretched.\n   */\n  set stretchLastRow(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastRow) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastRow = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * Get whether the last column is stretched.\n   */\n  get stretchLastColumn(): boolean {\n    return this._stretchLastColumn;\n  }\n\n  /**\n   * Set whether the last column is stretched.\n   */\n  set stretchLastColumn(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastColumn) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastColumn = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * The virtual width of the row headers.\n   */\n  get headerWidth(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'column') {\n      return 0;\n    }\n    return this._rowHeaderSections.length;\n  }\n\n  /**\n   * The virtual height of the column headers.\n   */\n  get headerHeight(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'row') {\n      return 0;\n    }\n    return this._columnHeaderSections.length;\n  }\n\n  /**\n   * The virtual width of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get bodyWidth(): number {\n    return this._columnSections.length;\n  }\n\n  /**\n   * The virtual height of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get bodyHeight(): number {\n    return this._rowSections.length;\n  }\n\n  /**\n   * The virtual width of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get totalWidth(): number {\n    return this.headerWidth + this.bodyWidth;\n  }\n\n  /**\n   * The virtual height of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get totalHeight(): number {\n    return this.headerHeight + this.bodyHeight;\n  }\n\n  /**\n   * The actual width of the viewport.\n   */\n  get viewportWidth(): number {\n    return this._viewportWidth;\n  }\n\n  /**\n   * The actual height of the viewport.\n   */\n  get viewportHeight(): number {\n    return this._viewportHeight;\n  }\n\n  /**\n   * The width of the visible portion of the grid body.\n   */\n  get pageWidth(): number {\n    return Math.max(0, this.viewportWidth - this.headerWidth);\n  }\n\n  /**\n   * The height of the visible portion of the grid body.\n   */\n  get pageHeight(): number {\n    return Math.max(0, this.viewportHeight - this.headerHeight);\n  }\n\n  /**\n   * The current scroll X position of the viewport.\n   */\n  get scrollX(): number {\n    return this._hScrollBar.value;\n  }\n\n  /**\n   * The current scroll Y position of the viewport.\n   */\n  get scrollY(): number {\n    return this._vScrollBar.value;\n  }\n\n  /**\n   * The maximum scroll X position for the grid.\n   */\n  get maxScrollX(): number {\n    return Math.max(0, this.bodyWidth - this.pageWidth - 1);\n  }\n\n  /**\n   * The maximum scroll Y position for the grid.\n   */\n  get maxScrollY(): number {\n    return Math.max(0, this.bodyHeight - this.pageHeight - 1);\n  }\n\n  /**\n   * The viewport widget for the data grid.\n   */\n  get viewport(): Widget {\n    return this._viewport;\n  }\n\n  /**\n   * The cell editor controller object for the data grid.\n   */\n  get editorController(): ICellEditorController | null {\n    return this._editorController;\n  }\n\n  set editorController(controller: ICellEditorController | null) {\n    this._editorController = controller;\n  }\n\n  /**\n   * Whether the cell editing is enabled for the data grid.\n   */\n  get editingEnabled(): boolean {\n    return this._editingEnabled;\n  }\n\n  set editingEnabled(enabled: boolean) {\n    this._editingEnabled = enabled;\n  }\n\n  /**\n   * Whether the grid cells are editable.\n   * \n   * `editingEnabled` flag must be on and grid must have required\n   * selection model, editor controller and data model properties.\n   */\n  get editable(): boolean {\n    return this._editingEnabled &&\n      this._selectionModel !== null &&\n      this._editorController !== null &&\n      this.dataModel instanceof MutableDataModel;\n  }\n\n  /**\n   * The rendering context for painting the data grid.\n   */\n  protected get canvasGC(): CanvasRenderingContext2D {\n    return this._canvasGC;\n  }\n\n  /**\n   * The row sections of the data grid.\n   */\n  protected get rowSections(): SectionList {\n    return this._rowSections;\n  }\n\n  /**\n   * The column sections of the data grid. \n   */\n  protected get columnSections(): SectionList {\n    return this._columnSections;\n  }\n\n  /**\n   * The row header sections of the data grid.\n   */\n  protected get rowHeaderSections(): SectionList {\n    return this._rowHeaderSections;\n  }\n\n  /**\n   * The column header sections of the data grid.\n   */\n  protected get columnHeaderSections(): SectionList {\n    return this._columnHeaderSections;\n  }\n\n  /**\n   * Scroll the grid to the specified row.\n   *\n   * @param row - The row index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the row is already visible.\n   */\n  scrollToRow(row: number): void {\n    // Fetch the row count.\n    let nr = this._rowSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0) {\n      return;\n    }\n\n    // Floor the row index.\n    row = Math.floor(row);\n\n    // Clamp the row index.\n    row = Math.max(0, Math.min(row, nr - 1));\n\n    // Get the virtual bounds of the row.\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dy = 0;\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(0, dy);\n  }\n\n  /**\n   * Scroll the grid to the specified column.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the column is already visible.\n   */\n  scrollToColumn(column: number): void {\n    // Fetch the column count.\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nc === 0) {\n      return;\n    }\n\n    // Floor the column index.\n    column = Math.floor(column);\n\n    // Clamp the column index.\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the column.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, 0);\n  }\n\n  /**\n   * Scroll the grid to the specified cell.\n   *\n   * @param row - The row index of the cell.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the cell is already visible.\n   */\n  scrollToCell(row: number, column: number): void {\n    // Fetch the row and column count.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0 || nc === 0) {\n      return;\n    }\n\n    // Floor the cell index.\n    row = Math.floor(row);\n    column = Math.floor(column);\n\n    // Clamp the cell index.\n    row = Math.max(0, Math.min(row, nr - 1));\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the cell.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n    let dy = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, dy);\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   * \n   * @param direction - The direction of the movement.\n   */\n  moveCursor(direction: SelectionModel.CursorMoveDirection): void {\n    // Bail early if there is no selection\n    if (!this.dataModel ||\n      !this._selectionModel ||\n      this._selectionModel.isEmpty) {\n      return;\n    }\n\n    const iter = this._selectionModel.selections();\n    const onlyOne = iter.next() && !iter.next();\n\n    // if there is a single selection that is a single cell selection\n    // then move the selection and cursor within grid bounds\n    if (onlyOne) {\n      const currentSel = this._selectionModel.currentSelection()!;\n      if (currentSel.r1 === currentSel.r2 &&\n        currentSel.c1 === currentSel.c2\n      ) {\n        const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n        const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n        let newRow = currentSel.r1 + dr;\n        let newColumn = currentSel.c1 + dc;\n        const rowCount = this.dataModel.rowCount('body');\n        const columnCount = this.dataModel.columnCount('body');\n        if (newRow >= rowCount) {\n          newRow = 0;\n          newColumn += 1;\n        } else if (newRow === -1) {\n          newRow = rowCount - 1;\n          newColumn -= 1;\n        }\n        if (newColumn >= columnCount) {\n          newColumn = 0;\n          newRow += 1;\n          if (newRow >= rowCount) {\n            newRow = 0;\n          }\n        } else if (newColumn === -1) {\n          newColumn = columnCount - 1;\n          newRow -= 1;\n          if (newRow === -1) {\n            newRow = rowCount - 1;\n          }\n        }\n\n        this._selectionModel.select({\n          r1: newRow, c1: newColumn,\n          r2: newRow, c2: newColumn,\n          cursorRow: newRow, cursorColumn: newColumn,\n          clear: 'all'\n        });\n\n        return;\n      }\n    }\n\n    // if there are multiple selections, move cursor\n    // within selection rectangles\n    this._selectionModel.moveCursorWithinSelections(direction);\n  }\n\n  /**\n   * Scroll the grid to the current cursor position.\n   *\n   * #### Notes\n   * This is a no-op if the cursor is already visible or\n   * if there is no selection model installed on the grid.\n   */\n  scrollToCursor(): void {\n    // Bail early if there is no selection model.\n    if (!this._selectionModel) {\n      return;\n    }\n\n    // Fetch the cursor row and column.\n    let row = this._selectionModel.cursorRow;\n    let column = this._selectionModel.cursorColumn;\n\n    // Scroll to the cursor cell.\n    this.scrollToCell(row, column);\n  }\n\n  /**\n   * Scroll the viewport by the specified amount.\n   *\n   * @param dx - The X scroll amount.\n   *\n   * @param dy - The Y scroll amount.\n   */\n  scrollBy(dx: number, dy: number): void {\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one page.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByPage(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let dx = 0;\n    let dy = 0;\n    switch (dir) {\n    case 'up':\n      dy = -this.pageHeight;\n      break;\n    case 'down':\n      dy = this.pageHeight;\n      break;\n    case 'left':\n      dx = -this.pageWidth;\n      break;\n    case 'right':\n      dx = this.pageWidth;\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one cell-aligned step.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByStep(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let r: number;\n    let c: number;\n    let x = this.scrollX;\n    let y = this.scrollY;\n    let rows = this._rowSections;\n    let columns = this._columnSections;\n    switch (dir) {\n    case 'up':\n      r = rows.indexOf(y - 1);\n      y = r < 0 ? y : rows.offsetOf(r);\n      break;\n    case 'down':\n      r = rows.indexOf(y);\n      y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);\n      break;\n    case 'left':\n      c = columns.indexOf(x - 1);\n      x = c < 0 ? x : columns.offsetOf(c);\n      break;\n    case 'right':\n      c = columns.indexOf(x);\n      x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.scrollTo(x, y);\n  }\n\n  /**\n   * Scroll to the specified offset position.\n   *\n   * @param x - The desired X position.\n   *\n   * @param y - The desired Y position.\n   */\n  scrollTo(x: number, y: number): void {\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Update the scroll bar values with the desired position.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Post a scroll request message to the viewport.\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Get the row count for a particular region in the data grid.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns The row count for the specified region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._rowSections.count;\n    } else {\n      count = this._columnHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the column count for a particular region in the data grid.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns The column count for the specified region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._columnSections.count;\n    } else {\n      count = this._rowHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the row at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param offset - The virtual offset of the row of interest.\n   *\n   * @returns The index of the row, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowAt(region: DataModel.RowRegion, offset: number): number {\n    // Bail early if the offset is negative.\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._rowSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Bail early if no row stretching is required.\n    if (ph <= bh) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= ph) {\n      return -1;\n    }\n\n    // Otherwise, return the last row.\n    return this._rowSections.count - 1;\n  }\n\n  /**\n   * Get the column at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param offset - The virtual offset of the column of interest.\n   *\n   * @returns The index of the column, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnAt(region: DataModel.ColumnRegion, offset: number): number {\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._columnSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Bail early if no column stretching is required.\n    if (pw <= bw) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= pw) {\n      return -1;\n    }\n\n    // Otherwise, return the last column.\n    return this._columnSections.count - 1;\n  }\n\n  /**\n   * Get the offset of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The offset of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last row has no effect on the return value.\n   */\n  rowOffset(region: DataModel.RowRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._rowSections.offsetOf(index);\n    } else {\n      offset = this._columnHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the offset of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The offset of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last column has no effect on the return value.\n   */\n  columnOffset(region: DataModel.ColumnRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._columnSections.offsetOf(index);\n    } else {\n      offset = this._rowHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the size of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The size of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowSize(region: DataModel.RowRegion, index: number): number {\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the row size.\n    let size = this._rowSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return size;\n    }\n\n    // Return early if its not the last row.\n    if (index < this._rowSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Return early if no stretching is needed.\n    if (ph <= bh) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (ph - bh);\n  }\n\n  /**\n   * Get the size of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The size of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnSize(region: DataModel.ColumnRegion, index: number): number {\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the column size.\n    let size = this._columnSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return size;\n    }\n\n    // Return early if its not the last column.\n    if (index < this._columnSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Return early if no stretching is needed.\n    if (pw <= bw) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (pw - bw);\n  }\n\n  /**\n   * Resize a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @param size - The desired size of the row.\n   */\n  resizeRow(region: DataModel.RowRegion, index: number, size: number): void {\n    let msg = new Private.RowResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Resize a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @param size - The desired size of the column.\n   */\n  resizeColumn(region: DataModel.ColumnRegion, index: number, size: number): void {\n    let msg = new Private.ColumnResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Reset modified rows to their default size.\n   *\n   * @param region - The row region of interest.\n   */\n  resetRows(region: DataModel.RowRegion | 'all'): void {\n    switch (region) {\n    case 'all':\n      this._rowSections.reset();\n      this._columnHeaderSections.reset();\n      break;\n    case 'body':\n      this._rowSections.reset();\n      break;\n    case 'column-header':\n      this._columnHeaderSections.reset();\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Reset modified columns to their default size.\n   *\n   * @param region - The column region of interest.\n   */\n  resetColumns(region: DataModel.ColumnRegion | 'all'): void {\n    switch (region) {\n    case 'all':\n      this._columnSections.reset();\n      this._rowHeaderSections.reset();\n      break;\n    case 'body':\n      this._columnSections.reset();\n      break;\n    case 'row-header':\n      this._rowHeaderSections.reset();\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Map a client position to local viewport coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The local viewport coordinates for the position.\n   */\n  mapToLocal(clientX: number, clientY: number): { lx: number, ly: number } {\n    // Fetch the viewport rect.\n    let rect = this._viewport.node.getBoundingClientRect();\n\n    // Extract the rect coordinates.\n    let { left, top } = rect;\n\n    // Round the rect coordinates for sub-pixel positioning.\n    left = Math.floor(left);\n    top = Math.floor(top);\n\n    // Convert to local coordinates.\n    let lx = clientX - left;\n    let ly = clientY - top;\n\n    // Return the local coordinates.\n    return { lx, ly };\n  }\n\n  /**\n   * Map a client position to virtual grid coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The virtual grid coordinates for the position.\n   */\n  mapToVirtual(clientX: number, clientY: number): { vx: number, vy: number } {\n    // Convert to local coordiates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Convert to virtual coordinates.\n    let vx = lx + this.scrollX - this.headerWidth;\n    let vy = ly + this.scrollY - this.headerHeight;\n\n    // Return the local coordinates.\n    return { vx, vy };\n  }\n\n  /**\n   * Hit test the viewport for the given client position.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The hit test result, or `null` if the client\n   *   position is out of bounds.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row and/or column.\n   */\n  hitTest(clientX: number, clientY: number): DataGrid.HitTestResult {\n    // Convert the mouse position into local coordinates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Fetch the header and body dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Adjust the body width for a stretched last column.\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Adjust the body height for a stretched last row.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n\n    // Check for a corner header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < hh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx;\n      let vy = ly;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'corner-header', row, column, x, y, width, height };\n    }\n\n    // Check for a column header hit.\n    if (ly >= 0 && ly < hh && lx >= 0 && lx < (hw + bw)) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw;\n      let vy = ly\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'column-header', row, column, x, y, width, height };\n    }\n\n    // Check for a row header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < (hh + bh)) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'row-header', row, column, x, y, width, height };\n    }\n\n    // Check for a body hit.\n    if (lx >= hw && lx < (hw + bw) && ly >= hh && ly < (hh + bh)) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the part coordinates.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the result.\n      return { region: 'body', row, column, x, y, width, height };\n    }\n\n    // Otherwise, it's a void space hit.\n    let row = -1;\n    let column = -1;\n    let x = -1;\n    let y = -1;\n    let width = -1;\n    let height = -1;\n\n    // Return the hit test result.\n    return { region: 'void', row, column, x, y, width, height };\n  }\n\n  /**\n   * Copy the current selection to the system clipboard.\n   *\n   * #### Notes\n   * The grid must have a data model and a selection model.\n   *\n   * The behavior can be configured via `DataGrid.copyConfig`.\n   */\n  copyToClipboard(): void {\n    // Fetch the data model.\n    let dataModel = this._dataModel;\n\n    // Bail early if there is no data model.\n    if (!dataModel) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let selectionModel = this._selectionModel;\n\n    // Bail early if there is no selection model.\n    if (!selectionModel) {\n      return;\n    }\n\n    // Coerce the selections to an array.\n    let selections = toArray(selectionModel.selections());\n\n    // Bail early if there are no selections.\n    if (selections.length === 0) {\n      return;\n    }\n\n    // Alert that multiple selections cannot be copied.\n    if (selections.length > 1) {\n      alert('Cannot copy multiple grid selections.');\n      return;\n    }\n\n    // Fetch the model counts.\n    let br = dataModel.rowCount('body');\n    let bc = dataModel.columnCount('body');\n\n    // Bail early if there is nothing to copy.\n    if (br === 0 || bc === 0) {\n      return;\n    }\n\n    // Unpack the selection.\n    let { r1, c1, r2, c2 } = selections[0];\n\n    // Clamp the selection to the model bounds.\n    r1 = Math.max(0, Math.min(r1, br - 1));\n    c1 = Math.max(0, Math.min(c1, bc - 1));\n    r2 = Math.max(0, Math.min(r2, br - 1));\n    c2 = Math.max(0, Math.min(c2, bc - 1));\n\n    // Ensure the limits are well-orderd.\n    if (r2 < r1) [r1, r2] = [r2, r1];\n    if (c2 < c1) [c1, c2] = [c2, c1];\n\n    // Fetch the header counts.\n    let rhc = dataModel.columnCount('row-header');\n    let chr = dataModel.rowCount('column-header');\n\n    // Unpack the copy config.\n    let separator = this._copyConfig.separator;\n    let format = this._copyConfig.format;\n    let headers = this._copyConfig.headers;\n    let warningThreshold = this._copyConfig.warningThreshold;\n\n    // Compute the number of cells to be copied.\n    let rowCount = r2 - r1 + 1;\n    let colCount = c2 - c1 + 1;\n    switch (headers) {\n    case 'none':\n      rhc = 0;\n      chr = 0;\n      break;\n    case 'row':\n      chr = 0;\n      colCount += rhc;\n      break;\n    case 'column':\n      rhc = 0;\n      rowCount += chr;\n      break;\n    case 'all':\n      rowCount += chr;\n      colCount += rhc;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Compute the total cell count.\n    let cellCount = rowCount * colCount;\n\n    // Allow the user to cancel a large copy request.\n    if (cellCount > warningThreshold) {\n      let msg = `Copying ${cellCount} cells may take a while. Continue?`;\n      if (!window.confirm(msg)) {\n        return;\n      }\n    }\n\n    // Set up the format args.\n    let args = {\n      region: 'body' as DataModel.CellRegion,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: {} as DataModel.Metadata\n    };\n\n    // Allocate the array of rows.\n    let rows = new Array<string[]>(rowCount);\n\n    // Iterate over the rows.\n    for (let j = 0; j < rowCount; ++j) {\n      // Allocate the array of cells.\n      let cells = new Array<string>(colCount);\n\n      // Iterate over the columns.\n      for (let i = 0; i < colCount; ++i) {\n        // Set up the format variables.\n        let region: DataModel.CellRegion;\n        let row: number;\n        let column: number;\n\n        // Populate the format variables.\n        if (j < chr && i < rhc) {\n          region = 'corner-header';\n          row = j;\n          column = i;\n        } else if (j < chr) {\n          region = 'column-header';\n          row = j;\n          column = i - rhc + c1;\n        } else if (i < rhc) {\n          region = 'row-header';\n          row = j - chr + r1;\n          column = i;\n        } else {\n          region = 'body';\n          row = j - chr + r1;\n          column = i - rhc + c1;\n        }\n\n        // Populate the format args.\n        args.region = region;\n        args.row = row;\n        args.column = column;\n        args.value = dataModel.data(region, row, column);\n        args.metadata = dataModel.metadata(region, row, column);\n\n        // Format the cell.\n        cells[i] = format(args);\n      }\n\n      // Save the row of cells.\n      rows[j] = cells;\n    }\n\n    // Convert the cells into lines.\n    let lines = rows.map(cells => cells.join(separator));\n\n    // Convert the lines into text.\n    let text = lines.join('\\n');\n\n    // Copy the text to the clipboard.\n    ClipboardExt.copyText(text);\n  }\n\n  /**\n   * Process a message sent to the widget.\n   *\n   * @param msg - The message sent to the widget.\n   */\n  processMessage(msg: Message): void {\n    // Ignore child show/hide messages. The data grid controls the\n    // visibility of its children, and will manually dispatch the\n    // fit-request messages as a result of visibility change.\n    if (msg.type === 'child-shown' || msg.type === 'child-hidden') {\n      return;\n    }\n\n    // Recompute the scroll bar minimums before the layout refits.\n    if (msg.type === 'fit-request') {\n      let vsbLimits = ElementExt.sizeLimits(this._vScrollBar.node);\n      let hsbLimits = ElementExt.sizeLimits(this._hScrollBar.node);\n      this._vScrollBarMinWidth = vsbLimits.minWidth;\n      this._hScrollBarMinHeight = hsbLimits.minHeight;\n    }\n\n    // Process all other messages as normal.\n    super.processMessage(msg);\n  }\n\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean {\n    // Process viewport messages.\n    if (handler === this._viewport) {\n      this._processViewportMessage(msg);\n      return true;\n    }\n\n    // Process horizontal scroll bar messages.\n    if (handler === this._hScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Process vertical scroll bar messages.\n    if (handler === this._vScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Ignore all other messages.\n    return true;\n  }\n\n  /**\n   * Handle the DOM events for the data grid.\n   *\n   * @param event - The DOM event sent to the data grid.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the data grid's DOM node. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n    case 'keydown':\n      this._evtKeyDown(event as KeyboardEvent);\n      break;\n    case 'mousedown':\n      this._evtMouseDown(event as MouseEvent);\n      break;\n    case 'mousemove':\n      this._evtMouseMove(event as MouseEvent);\n      break;\n    case 'mouseup':\n      this._evtMouseUp(event as MouseEvent);\n      break;\n    case 'dblclick':\n      this._evtMouseDoubleClick(event as MouseEvent);\n      break;\n    case 'mouseleave':\n      this._evtMouseLeave(event as MouseEvent);\n      break;\n    case 'contextmenu':\n      this._evtContextMenu(event as MouseEvent);\n      break;\n    case 'wheel':\n      this._evtWheel(event as WheelEvent);\n      break;\n    case 'resize':\n      this._refreshDPI();\n      break;\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.viewport.node.focus();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    window.addEventListener('resize', this);\n    this.node.addEventListener('wheel', this);\n    this._viewport.node.addEventListener('keydown', this);\n    this._viewport.node.addEventListener('mousedown', this);\n    this._viewport.node.addEventListener('mousemove', this);\n    this._viewport.node.addEventListener('dblclick', this);\n    this._viewport.node.addEventListener('mouseleave', this);\n    this._viewport.node.addEventListener('contextmenu', this);\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    window.removeEventListener('resize', this);\n    this.node.removeEventListener('wheel', this);\n    this._viewport.node.removeEventListener('keydown', this);\n    this._viewport.node.removeEventListener('mousedown', this);\n    this._viewport.node.removeEventListener('mousemove', this);\n    this._viewport.node.removeEventListener('mouseleave', this);\n    this._viewport.node.removeEventListener('dblclick', this);\n    this._viewport.node.removeEventListener('contextmenu', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this._editorController) {\n      this._editorController.cancel();\n    }\n\n    this._syncScrollState();\n  }\n\n  /**\n   * Schedule a repaint of all of the grid content.\n   */\n  protected repaintContent(): void {\n    let msg = new Private.PaintRequest('all', 0, 0, 0, 0);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of specific grid content.\n   */\n  private _repaintRegion(region: DataModel.CellRegion, r1: number, c1: number, r2: number, c2: number): void {\n    let msg = new Private.PaintRequest(region, r1, c1, r2, c2);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of the overlay.\n   */\n  protected repaintOverlay(): void {\n    MessageLoop.postMessage(this._viewport, Private.OverlayPaintRequest);\n  }\n\n  /**\n   * Ensure the canvas is at least the specified size.\n   *\n   * This method will retain the valid canvas content.\n   */\n  private _resizeCanvasIfNeeded(width: number, height: number): void {\n    // Scale the size by the dpi ratio.\n    width = width * this._dpiRatio;\n    height = height * this._dpiRatio;\n\n    // Compute the maximum canvas size for the given width and height.\n    let maxW = (Math.ceil((width + 1) / 512) + 1) * 512;\n    let maxH = (Math.ceil((height + 1) / 512) + 1) * 512;\n\n    // Get the current size of the canvas.\n    let curW = this._canvas.width;\n    let curH = this._canvas.height;\n\n    // Bail early if the canvas size is within bounds.\n    if (curW >= width && curH >= height && curW <= maxW && curH <= maxH) {\n      return;\n    }\n\n    // Compute the expanded canvas size.\n    let expW = maxW - 512;\n    let expH = maxH - 512;\n\n    // Set the transforms to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Resize the buffer if needed.\n    if (curW < width) {\n      this._buffer.width = expW;\n    } else if (curW > maxW) {\n      this._buffer.width = maxW;\n    }\n\n    // Resize the buffer height if needed.\n    if (curH < height) {\n      this._buffer.height = expH;\n    } else if (curH > maxH) {\n      this._buffer.height = maxH;\n    }\n\n    // Test whether there is content to blit.\n    let needBlit = curH > 0 && curH > 0 && width > 0 && height > 0;\n\n    // Copy the valid canvas content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._canvas, 0, 0);\n    }\n\n    // Resize the canvas width if needed.\n    if (curW < width) {\n      this._canvas.width = expW;\n      this._canvas.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._canvas.width = maxW;\n      this._canvas.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the canvas height if needed.\n    if (curH < height) {\n      this._canvas.height = expH;\n      this._canvas.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._canvas.height = maxH;\n      this._canvas.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid canvas content from the buffer if needed.\n    if (needBlit) {\n      this._canvasGC.drawImage(this._buffer, 0, 0);\n    }\n\n    // Copy the valid overlay content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._overlay, 0, 0);\n    }\n\n    // Resize the overlay width if needed.\n    if (curW < width) {\n      this._overlay.width = expW;\n      this._overlay.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._overlay.width = maxW;\n      this._overlay.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the overlay height if needed.\n    if (curH < height) {\n      this._overlay.height = expH;\n      this._overlay.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._overlay.height = maxH;\n      this._overlay.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid overlay content from the buffer if needed.\n    if (needBlit) {\n      this._overlayGC.drawImage(this._buffer, 0, 0);\n    }\n  }\n\n  /**\n   * Sync the scroll bars and scroll state with the viewport.\n   *\n   * #### Notes\n   * If the visibility of either scroll bar changes, a synchronous\n   * fit-request will be dispatched to the data grid to immediately\n   * resize the viewport.\n   */\n  private _syncScrollState(): void {\n    // Fetch the viewport dimensions.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Get the current scroll bar visibility.\n    let hasVScroll = !this._vScrollBar.isHidden;\n    let hasHScroll = !this._hScrollBar.isHidden;\n\n    // Get the minimum sizes of the scroll bars.\n    let vsw = this._vScrollBarMinWidth;\n    let hsh = this._hScrollBarMinHeight;\n\n    // Get the page size as if no scroll bars are visible.\n    let apw = pw + (hasVScroll ? vsw : 0);\n    let aph = ph + (hasHScroll ? hsh : 0);\n\n    // Test whether scroll bars are needed for the adjusted size.\n    let needVScroll = aph < bh - 1;\n    let needHScroll = apw < bw - 1;\n\n    // Re-test the horizontal scroll if a vertical scroll is needed.\n    if (needVScroll && !needHScroll) {\n      needHScroll = (apw - vsw) < bw - 1;\n    }\n\n    // Re-test the vertical scroll if a horizontal scroll is needed.\n    if (needHScroll && !needVScroll) {\n      needVScroll = (aph - hsh) < bh - 1;\n    }\n\n    // If the visibility changes, immediately refit the grid.\n    if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {\n      this._vScrollBar.setHidden(!needVScroll);\n      this._hScrollBar.setHidden(!needHScroll);\n      this._scrollCorner.setHidden(!needVScroll || !needHScroll);\n      MessageLoop.sendMessage(this, Widget.Msg.FitRequest);\n    }\n\n    // Update the scroll bar limits.\n    this._vScrollBar.maximum = this.maxScrollY;\n    this._vScrollBar.page = this.pageHeight;\n    this._hScrollBar.maximum = this.maxScrollX;\n    this._hScrollBar.page = this.pageWidth;\n\n    // Re-clamp the scroll position.\n    this._scrollTo(this._scrollX, this._scrollY);\n  }\n\n  /**\n   * Sync the viewport to the given scroll position.\n   *\n   * #### Notes\n   * This schedules a full repaint and syncs the scroll state.\n   */\n  private _syncViewport(): void {\n    this.repaintContent();\n    this.repaintOverlay();\n    this._syncScrollState();\n  }\n\n  /**\n   * Process a message sent to the viewport\n   */\n  private _processViewportMessage(msg: Message): void {\n    switch (msg.type) {\n    case 'resize':\n      this._onViewportResize(msg as Widget.ResizeMessage);\n      break;\n    case 'scroll-request':\n      this._onViewportScrollRequest(msg);\n      break;\n    case 'paint-request':\n      this._onViewportPaintRequest(msg as Private.PaintRequest);\n      break;\n    case 'overlay-paint-request':\n      this._onViewportOverlayPaintRequest(msg);\n      break;\n    case 'row-resize-request':\n      this._onViewportRowResizeRequest(msg as Private.RowResizeRequest);\n      break;\n    case 'column-resize-request':\n      this._onViewportColumnResizeRequest(msg as Private.ColumnResizeRequest);\n      break;\n    default:\n      break;\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'resize'` message.\n   */\n  private _onViewportResize(msg: Widget.ResizeMessage): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Unpack the message data.\n    let { width, height } = msg;\n\n    // Measure the viewport node if the dimensions are unknown.\n    if (width === -1) {\n      width = this._viewport.node.offsetWidth;\n    }\n    if (height === -1) {\n      height = this._viewport.node.offsetHeight;\n    }\n\n    // Round the dimensions to the nearest pixel.\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // Get the current size of the viewport.\n    let oldWidth = this._viewportWidth;\n    let oldHeight = this._viewportHeight;\n\n    // Updated internal viewport size.\n    this._viewportWidth = width;\n    this._viewportHeight = height;\n\n    // Resize the canvas if needed.\n    this._resizeCanvasIfNeeded(width, height);\n\n    // Bail early if there is nothing to paint.\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    // Paint the whole grid if the old size was zero.\n    if (oldWidth === 0 || oldHeight === 0) {\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Paint the right edge as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let bx = this._columnSections.offsetOf(this._columnSections.count - 1);\n      let x = Math.min(this.headerWidth + bx, oldWidth);\n      this.paintContent(x, 0, width - x, height);\n    } else if (width > oldWidth) {\n      this.paintContent(oldWidth, 0, width - oldWidth, height);\n    }\n\n    // Paint the bottom edge as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let by = this._rowSections.offsetOf(this._rowSections.count - 1);\n      let y = Math.min(this.headerHeight + by, oldHeight);\n      this.paintContent(0, y, width, height - y);\n    } else if (height > oldHeight) {\n      this.paintContent(0, oldHeight, width, height - oldHeight);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'scroll-request'` message.\n   */\n  private _onViewportScrollRequest(msg: Message): void {\n    this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'paint-request'` message.\n   */\n  private _onViewportPaintRequest(msg: Private.PaintRequest): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Set up the paint limits.\n    let xMin = 0;\n    let yMin = 0;\n    let xMax = this._viewportWidth - 1;\n    let yMax = this._viewportHeight - 1;\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch the header dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the section lists.\n    let rs = this._rowSections;\n    let cs = this._columnSections;\n    let rhs = this._rowHeaderSections;\n    let chs = this._columnHeaderSections;\n\n    // Unpack the message data.\n    let { region, r1, c1, r2, c2 } = msg;\n\n    // Set up the paint variables.\n    let x1: number;\n    let y1: number;\n    let x2: number;\n    let y2: number;\n\n    // Fill the paint variables based on the paint region.\n    switch (region) {\n    case 'all':\n      x1 = xMin;\n      y1 = yMin;\n      x2 = xMax;\n      y2 = yMax;\n      break;\n    case 'body':\n      r1 = Math.max(0, Math.min(r1, rs.count));\n      c1 = Math.max(0, Math.min(c1, cs.count));\n      r2 = Math.max(0, Math.min(r2, rs.count));\n      c2 = Math.max(0, Math.min(c2, cs.count));\n      x1 = cs.offsetOf(c1) - sx + hw;\n      y1 = rs.offsetOf(r1) - sy + hh;\n      x2 = cs.extentOf(c2) - sx + hw;\n      y2 = rs.extentOf(r2) - sy + hh;\n      break;\n    case 'row-header':\n      r1 = Math.max(0, Math.min(r1, rs.count));\n      c1 = Math.max(0, Math.min(c1, rhs.count));\n      r2 = Math.max(0, Math.min(r2, rs.count));\n      c2 = Math.max(0, Math.min(c2, rhs.count));\n      x1 = rhs.offsetOf(c1);\n      y1 = rs.offsetOf(r1) - sy + hh;\n      x2 = rhs.extentOf(c2);\n      y2 = rs.extentOf(r2) - sy + hh;\n      break;\n    case 'column-header':\n      r1 = Math.max(0, Math.min(r1, chs.count));\n      c1 = Math.max(0, Math.min(c1, cs.count));\n      r2 = Math.max(0, Math.min(r2, chs.count));\n      c2 = Math.max(0, Math.min(c2, cs.count));\n      x1 = cs.offsetOf(c1) - sx + hw;\n      y1 = chs.offsetOf(r1);\n      x2 = cs.extentOf(c2) - sx + hw;\n      y2 = chs.extentOf(r2);\n      break;\n    case 'corner-header':\n      r1 = Math.max(0, Math.min(r1, chs.count));\n      c1 = Math.max(0, Math.min(c1, rhs.count));\n      r2 = Math.max(0, Math.min(r2, chs.count));\n      c2 = Math.max(0, Math.min(c2, rhs.count));\n      x1 = rhs.offsetOf(c1);\n      y1 = chs.offsetOf(r1);\n      x2 = rhs.extentOf(c2);\n      y2 = chs.extentOf(r2);\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Bail early if the dirty rect is outside the bounds.\n    if (x2 < xMin || y2 < yMin || x1 > xMax || y1 > yMax) {\n      return;\n    }\n\n    // Clamp the dirty rect to the paint bounds.\n    x1 = Math.max(xMin, Math.min(x1, xMax));\n    y1 = Math.max(yMin, Math.min(y1, yMax));\n    x2 = Math.max(xMin, Math.min(x2, xMax));\n    y2 = Math.max(yMin, Math.min(y2, yMax));\n\n    // Paint the content of the dirty rect.\n    this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'overlay-paint-request'` message.\n   */\n  private _onViewportOverlayPaintRequest(msg: Message): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Paint the content of the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'row-resize-request'` message.\n   */\n  private _onViewportRowResizeRequest(msg: Private.RowResizeRequest): void {\n    if (msg.region === 'body') {\n      this._resizeRow(msg.index, msg.size);\n    } else {\n      this._resizeColumnHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'column-resize-request'` message.\n   */\n  private _onViewportColumnResizeRequest(msg: Private.ColumnResizeRequest): void {\n    if (msg.region === 'body') {\n      this._resizeColumn(msg.index, msg.size);\n    } else {\n      this._resizeRowHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * Handle the `thumbMoved` signal from a scroll bar.\n   */\n  private _onThumbMoved(sender: ScrollBar): void {\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Handle the `pageRequested` signal from a scroll bar.\n   */\n  private _onPageRequested(sender: ScrollBar, dir: 'decrement' | 'increment'): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByPage(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByPage(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * Handle the `stepRequested` signal from a scroll bar.\n   */\n  private _onStepRequested(sender: ScrollBar, dir: 'decrement' | 'increment'): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByStep(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByStep(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   */\n  private _onDataModelChanged(sender: DataModel, args: DataModel.ChangedArgs): void {\n    switch (args.type) {\n    case 'rows-inserted':\n      this._onRowsInserted(args);\n      break;\n    case 'columns-inserted':\n      this._onColumnsInserted(args);\n      break;\n    case 'rows-removed':\n      this._onRowsRemoved(args);\n      break;\n    case 'columns-removed':\n      this._onColumnsRemoved(args);\n      break;\n    case 'rows-moved':\n      this._onRowsMoved(args);\n      break;\n    case 'columns-moved':\n      this._onColumnsMoved(args);\n      break;\n    case 'cells-changed':\n      this._onCellsChanged(args);\n      break;\n    case 'model-reset':\n      this._onModelReset(args);\n      break;\n    default:\n      throw 'unreachable';\n    }\n  }\n\n  /**\n   * A signal handler for the selection model `changed` signal.\n   */\n  private _onSelectionsChanged(sender: SelectionModel): void {\n    this.repaintOverlay();\n  }\n\n  /**\n   * Handle rows being inserted in the data model.\n   */\n  private _onRowsInserted(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.insert(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being inserted into the data model.\n   */\n  private _onColumnsInserted(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.insert(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows being removed from the data model.\n   */\n  private _onRowsRemoved(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.remove(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being removed from the data model.\n   */\n  private _onColumnsRemoved(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.remove(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows moving in the data model.\n   */\n  private _onRowsMoved(args: DataModel.RowsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let r1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let r2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this._repaintRegion('body', r1, 0, r2, Infinity);\n      this._repaintRegion('row-header', r1, 0, r2, Infinity);\n    } else {\n      this._repaintRegion('column-header', r1, 0, r2, Infinity);\n      this._repaintRegion('corner-header', r1, 0, r2, Infinity);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns moving in the data model.\n   */\n  private _onColumnsMoved(args: DataModel.ColumnsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Compute the first affected index.\n    let c1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let c2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this._repaintRegion('body', 0, c1, Infinity, c2);\n      this._repaintRegion('column-header', 0, c1, Infinity, c2);\n    } else {\n      this._repaintRegion('row-header', 0, c1, Infinity, c2);\n      this._repaintRegion('corner-header', 0, c1, Infinity, c2);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle cells changing in the data model.\n   */\n  private _onCellsChanged(args: DataModel.CellsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, row, column, rowSpan, columnSpan } = args;\n\n    // Bail early if there are no cells to modify.\n    if (rowSpan <= 0 && columnSpan <= 0) {\n      return;\n    }\n\n    // Compute the changed cell bounds.\n    let r1 = row;\n    let c1 = column;\n    let r2 = r1 + rowSpan - 1;\n    let c2 = c1 + columnSpan - 1;\n\n    // Schedule a repaint of the cell content.\n    this._repaintRegion(region, r1, c1, r2, c2);\n  }\n\n  /**\n   * Handle a full data model reset.\n   */\n  private _onModelReset(args: DataModel.ModelResetArgs): void {\n    // Look up the various current section counts.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n    let nrh = this._rowHeaderSections.count;\n    let nch = this._columnHeaderSections.count;\n\n    // Compute the delta count for each region.\n    let dr = this._dataModel!.rowCount('body') - nr;\n    let dc = this._dataModel!.columnCount('body') - nc;\n    let drh = this._dataModel!.columnCount('row-header') - nrh;\n    let dch = this._dataModel!.rowCount('column-header') - nch;\n\n    // Update the row sections, if needed.\n    if (dr > 0) {\n      this._rowSections.insert(nr, dr);\n    } else if (dr < 0) {\n      this._rowSections.remove(nr + dr, -dr);\n    }\n\n    // Update the column sections, if needed.\n    if (dc > 0) {\n      this._columnSections.insert(nc, dc);\n    } else if (dc < 0) {\n      this._columnSections.remove(nc + dc, -dc);\n    }\n\n    // Update the row header sections, if needed.\n    if (drh > 0) {\n      this._rowHeaderSections.insert(nrh, drh);\n    } else if (drh < 0) {\n      this._rowHeaderSections.remove(nrh + drh, -drh);\n    }\n\n    // Update the column header sections, if needed.\n    if (dch > 0) {\n      this._columnHeaderSections.insert(nch, dch);\n    } else if (dch < 0) {\n      this._columnHeaderSections.remove(nch + dch, -dch);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * A signal handler for the renderer map `changed` signal.\n   */\n  private _onRenderersChanged(): void {\n    this.repaintContent();\n  }\n\n  /**\n   * Handle the `'keydown'` event for the data grid.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._keyHandler) {\n      this._keyHandler.onKeyDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the data grid.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Activate the grid.\n    this.activate();\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Add the extra document listeners.\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('mouseup', this, true);\n    document.addEventListener('mousedown', this, true);\n    document.addEventListener('mousemove', this, true);\n    document.addEventListener('contextmenu', this, true);\n\n    // Flip the mousedown flag.\n    this._mousedown = true;\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the data grid.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Stop the event propagation if the mouse is down.\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    // Bail if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Dispatch to the mouse handler.\n    if (this._mousedown) {\n      this._mouseHandler.onMouseMove(this, event);\n    } else {\n      this._mouseHandler.onMouseHover(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the data grid.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseUp(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'dblclick'` event for the data grid.\n   */\n  private _evtMouseDoubleClick(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDoubleClick(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'mouseleave'` event for the data grid.\n   */\n  private _evtMouseLeave(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onMouseLeave(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'contextmenu'` event for the data grid.\n   */\n  private _evtContextMenu(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onContextMenu(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'wheel'` event for the data grid.\n   */\n  private _evtWheel(event: WheelEvent): void {\n    // Ignore the event if `accel` is held.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Bail early if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    this._mouseHandler.onWheel(this, event);\n  }\n\n  /**\n   * Release the mouse grab.\n   */\n  private _releaseMouse(): void {\n    // Clear the mousedown flag.\n    this._mousedown = false;\n\n    // Relase the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.release();\n    }\n\n    // Remove the document listeners.\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('mouseup', this, true);\n    document.removeEventListener('mousedown', this, true);\n    document.removeEventListener('mousemove', this, true);\n    document.removeEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Refresh the dpi ratio.\n   */\n  private _refreshDPI(): void {\n    // Get the best integral value for the dpi ratio.\n    let dpiRatio = Math.ceil(window.devicePixelRatio);\n\n    // Bail early if the computed dpi ratio has not changed.\n    if (this._dpiRatio === dpiRatio) {\n      return;\n    }\n\n    // Update the internal dpi ratio.\n    this._dpiRatio = dpiRatio;\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n\n    // Update the canvas size for the new dpi ratio.\n    this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);\n\n    // Ensure the canvas style is scaled for the new ratio.\n    this._canvas.style.width = `${this._canvas.width / this._dpiRatio}px`;\n    this._canvas.style.height = `${this._canvas.height / this._dpiRatio}px`;\n\n    // Ensure the overlay style is scaled for the new ratio.\n    this._overlay.style.width = `${this._overlay.width / this._dpiRatio}px`;\n    this._overlay.style.height = `${this._overlay.height / this._dpiRatio}px`;\n  }\n\n  /**\n   * Resize a row section immediately.\n   */\n  private _resizeRow(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the column header height.\n    let hh = this.headerHeight;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hh - this._scrollY;\n\n    // Bail early if there is nothing to paint.\n    if (hh >= vh || offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hh) {\n      this._scrollY += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hh, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, pos, vw, vh - pos);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the X blit dimensions.\n    let sx = 0;\n    let sw = vw;\n    let dx = 0;\n\n    // Compute the Y blit dimensions.\n    let sy: number;\n    let sh: number;\n    let dy: number;\n    if (offset + newSize <= hh) {\n      sy = hh - delta;\n      sh = vh - sy;\n      dy = hh;\n    } else {\n      sy = offset + oldSize;\n      sh = vh - sy;\n      dy = sy + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hh) {\n      this.paintContent(0, pos, vw, offset + newSize - pos);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = hh + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column section immediately.\n   */\n  private _resizeColumn(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the row header width.\n    let hw = this.headerWidth;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hw - this._scrollX;\n\n    // Bail early if there is nothing to paint.\n    if (hw >= vw || offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hw) {\n      this._scrollX += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hw, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(pos, 0, vw - pos, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the Y blit dimensions.\n    let sy = 0;\n    let sh = vh;\n    let dy = 0;\n\n    // Compute the X blit dimensions.\n    let sx: number;\n    let sw: number;\n    let dx: number;\n    if (offset + newSize <= hw) {\n      sx = hw - delta;\n      sw = vw - sx;\n      dx = hw;\n    } else {\n      sx = offset + oldSize;\n      sw = vw - sx;\n      dx = sx + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hw) {\n      this.paintContent(pos, 0, offset + newSize - pos, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = hw + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a row header section immediately.\n   */\n  private _resizeRowHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(offset, 0, vw - offset, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = offset + oldSize;\n    let sy = 0;\n    let sw = vw - sx;\n    let sh = vh;\n    let dx = sx + delta;\n    let dy = 0;\n\n    // Blit the valid contents to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(offset, 0, newSize, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = this.headerWidth + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column header section immediately.\n   */\n  private _resizeColumnHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, offset, vw, vh - offset);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = 0;\n    let sy = offset + oldSize;\n    let sw = vw;\n    let sh = vh - sy;\n    let dx = 0;\n    let dy = sy + delta;\n\n    // Blit the valid contents to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(0, offset, vw, newSize);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = this.headerHeight + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Scroll immediately to the specified offset position.\n   */\n  private _scrollTo(x: number, y: number): void {\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Synchronize the scroll bar values.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Compute the delta scroll amount.\n    let dx = x - this._scrollX;\n    let dy = y - this._scrollY;\n\n    // Bail early if there is no effective scroll.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the current size of the viewport.\n    let width = this._viewportWidth;\n    let height = this._viewportHeight;\n\n    // Bail early if the viewport is empty.\n    if (width === 0 || height === 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Get the visible content dimensions.\n    let contentWidth = width - contentX;\n    let contentHeight = height - contentY;\n\n    // Bail early if there is no content to draw.\n    if (contentWidth <= 0 && contentHeight <= 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Compute the area which needs painting for the `dx` scroll.\n    let dxArea = 0;\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        dxArea = contentWidth * height;\n      } else {\n        dxArea = Math.abs(dx) * height;\n      }\n    }\n\n    // Compute the area which needs painting for the `dy` scroll.\n    let dyArea = 0;\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        dyArea = width * contentHeight;\n      } else {\n        dyArea = width * Math.abs(dy);\n      }\n    }\n\n    // If the area sum is larger than the total, paint everything.\n    if ((dxArea + dyArea) >= (width * height)) {\n      this._scrollX = x;\n      this._scrollY = y;\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Update the internal Y scroll position.\n    this._scrollY = y;\n\n    // Scroll the Y axis if needed. If the scroll distance exceeds\n    // the visible height, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        this.paintContent(0, contentY, width, contentHeight);\n      } else {\n        let x = 0;\n        let y = dy < 0 ? contentY : contentY + dy;\n        let w = width;\n        let h = contentHeight - Math.abs(dy);\n        this._blitContent(this._canvas, x, y, w, h, x, y - dy);\n        this.paintContent(0, dy < 0 ? contentY : height - dy, width, Math.abs(dy));\n      }\n    }\n\n    // Update the internal X scroll position.\n    this._scrollX = x;\n\n    // Scroll the X axis if needed. If the scroll distance exceeds\n    // the visible width, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        this.paintContent(contentX, 0, contentWidth, height);\n      } else {\n        let x = dx < 0 ? contentX : contentX + dx;\n        let y = 0;\n        let w = contentWidth - Math.abs(dx);\n        let h = height;\n        this._blitContent(this._canvas, x, y, w, h, x - dx, y);\n        this.paintContent(dx < 0 ? contentX : width - dx, 0, Math.abs(dx), height);\n      }\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * Blit content into the on-screen grid canvas.\n   *\n   * The rect should be expressed in viewport coordinates.\n   *\n   * This automatically accounts for the dpi ratio.\n   */\n  private _blitContent(source: HTMLCanvasElement, x: number, y: number, w: number, h: number, dx: number, dy: number): void {\n    // Scale the blit coordinates by the dpi ratio.\n    x *= this._dpiRatio;\n    y *= this._dpiRatio;\n    w *= this._dpiRatio;\n    h *= this._dpiRatio;\n    dx *= this._dpiRatio;\n    dy *= this._dpiRatio;\n\n    // Save the current gc state.\n    this._canvasGC.save();\n\n    // Set the transform to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Draw the specified content.\n    this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);\n\n    // Restore the gc state.\n    this._canvasGC.restore();\n  }\n\n  /**\n   * Paint the grid content for the given dirty rect.\n   *\n   * The rect should be expressed in valid viewport coordinates.\n   *\n   * This is the primary paint entry point. The individual `_draw*`\n   * methods should not be invoked directly. This method dispatches\n   * to the drawing methods in the correct order.\n   */\n  protected paintContent(rx: number, ry: number, rw: number, rh: number): void {\n    // Scale the canvas and buffer GC for the dpi ratio.\n    this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n    this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the dirty rect of all content.\n    this._canvasGC.clearRect(rx, ry, rw, rh);\n\n    // Draw the void region.\n    this._drawVoidRegion(rx, ry, rw, rh);\n\n    // Draw the body region.\n    this._drawBodyRegion(rx, ry, rw, rh);\n\n    // Draw the row header region.\n    this._drawRowHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the column header region.\n    this._drawColumnHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the corner header region.\n    this.drawCornerHeaderRegion(rx, ry, rw, rh);\n  }\n\n  /**\n   * Paint the overlay content for the entire grid.\n   *\n   * This is the primary overlay paint entry point. The individual\n   * `_draw*` methods should not be invoked directly. This method\n   * dispatches to the drawing methods in the correct order.\n   */\n  private _paintOverlay(): void {\n    // Scale the overlay GC for the dpi ratio.\n    this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the overlay of all content.\n    this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);\n\n    // Draw the body selections.\n    this._drawBodySelections();\n\n    // Draw the row header selections.\n    this._drawRowHeaderSelections();\n\n    // Draw the column header selections.\n    this._drawColumnHeaderSelections();\n\n    // Draw the cursor.\n    this._drawCursor();\n\n    // Draw the shadows.\n    this._drawShadows();\n  }\n\n  /**\n   * Draw the void region for the dirty rect.\n   */\n  private _drawVoidRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Look up the void color.\n    let color = this._style.voidColor;\n\n    // Bail if there is no void color.\n    if (!color) {\n      return;\n    }\n\n    // Fill the dirty rect with the void color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(rx, ry, rw, rh);\n  }\n\n  /**\n   * Draw the body region which intersects the dirty rect.\n   */\n  private _drawBodyRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this._columnSections.length - this._scrollX;\n    let contentH = this._rowSections.length - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let bw = this.bodyWidth;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is streched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Adjust the geometry if the last column is streched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'body',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.backgroundColor);\n\n    // Draw the row background.\n    this._drawRowBackground(rgn, this._style.rowBackgroundColor);\n\n    // Draw the column background.\n    this._drawColumnBackground(rgn, this._style.columnBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.horizontalGridLineColor ||\n      this._style.gridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.verticalGridLineColor ||\n      this._style.gridLineColor\n    );\n  }\n\n  /**\n   * Draw the row header region which intersects the dirty rect.\n   */\n  private _drawRowHeaderRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.bodyHeight - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Fetch max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._rowHeaderSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is stretched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'row-header',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.headerHorizontalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.headerVerticalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the column header region which intersects the dirty rect.\n   */\n  private _drawColumnHeaderRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this.bodyWidth - this._scrollX;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._columnHeaderSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last column is stretched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'column-header',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.headerHorizontalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.headerVerticalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the corner header region which intersects the dirty rect.\n   */\n  protected drawCornerHeaderRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = this._columnHeaderSections.count - 1;\n    }\n    if (c2 < 0) {\n      c2 = this._rowHeaderSections.count - 1;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'corner-header',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.headerHorizontalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.headerVerticalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the background for the given paint region.\n   */\n  private _drawBackground(rgn: Private.PaintRegion, color: string | undefined): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Unpack the region.\n    let { xMin, yMin, xMax, yMax } = rgn;\n\n    // Fill the region with the specified color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);\n  }\n\n  /**\n   * Draw the row background for the given paint region.\n   */\n  private _drawRowBackground(rgn: Private.PaintRegion, colorFn: ((i: number) => string) | undefined): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the X bounds for the row.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n    let x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);\n\n    // Draw the background for the rows in the region.\n    for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the row.\n      let color = colorFn(rgn.row + j);\n\n      // Fill the row with the background color if needed.\n      if (color) {\n        let y1 = Math.max(rgn.yMin, y);\n        let y2 = Math.min(y + size - 1, rgn.yMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n  }\n\n  /**\n   * Draw the column background for the given paint region.\n   */\n  private _drawColumnBackground(rgn: Private.PaintRegion, colorFn: ((i: number) => string) | undefined): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the Y bounds for the column.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n\n    // Draw the background for the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the column.\n      let color = colorFn(rgn.column + i);\n\n      // Fill the column with the background color if needed.\n      if (color) {\n        let x1 = Math.max(rgn.xMin, x);\n        let x2 = Math.min(x + size - 1, rgn.xMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n  }\n\n  /**\n   * Draw the cells for the given paint region.\n   */\n  private _drawCells(rgn: Private.PaintRegion): void {\n    // Bail if there is no data model.\n    if (!this._dataModel) {\n      return;\n    }\n\n    // Set up the cell config object for rendering.\n    let config = {\n      x: 0, y: 0, width: 0, height: 0,\n      region: rgn.region, row: 0, column: 0,\n      value: (null as any), metadata: DataModel.emptyMetadata\n    };\n\n    // Save the buffer gc before wrapping.\n    this._bufferGC.save();\n\n    // Wrap the buffer gc for painting the cells.\n    let gc = new GraphicsContext(this._bufferGC);\n\n    // Compute the actual Y bounds for the cell range.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n\n    // Loop over the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let width = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (width === 0) {\n        continue;\n      }\n\n      // Compute the column index.\n      let column = rgn.column + i;\n\n      // Update the config for the current column.\n      config.x = x;\n      config.width = width;\n      config.column = column;\n\n      // Clear the buffer rect for the column.\n      gc.clearRect(x, rgn.y, width, rgn.height);\n\n      // Save the GC state.\n      gc.save();\n\n      // Loop over the rows in the column.\n      for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n        // Fetch the size of the row.\n        let height = rgn.rowSizes[j];\n\n        // Skip zero sized rows.\n        if (height === 0) {\n          continue;\n        }\n\n        // Compute the row index.\n        let row = rgn.row + j;\n\n        // Get the value for the cell.\n        let value: any;\n        try {\n          value = this._dataModel.data(rgn.region, row, column);\n        } catch (err) {\n          value = undefined;\n          console.error(err);\n        }\n\n        // Get the metadata for the cell.\n        let metadata: DataModel.Metadata;\n        try {\n          metadata = this._dataModel.metadata(rgn.region, row, column);\n        } catch (err) {\n          metadata = DataModel.emptyMetadata;\n          console.error(err);\n        }\n\n        // Update the config for the current cell.\n        config.y = y;\n        config.height = height;\n        config.row = row;\n        config.value = value;\n        config.metadata = metadata;\n\n        // Get the renderer for the cell.\n        let renderer = this._cellRenderers.get(config);\n\n        // Save the GC state.\n        gc.save();\n\n        // Paint the cell into the off-screen buffer.\n        try {\n          renderer.paint(gc, config);\n        } catch (err) {\n          console.error(err);\n        }\n\n        // Restore the GC state.\n        gc.restore();\n\n        // Increment the running Y coordinate.\n        y += height;\n      }\n\n      // Restore the GC state.\n      gc.restore();\n\n      // Compute the actual X bounds for the column.\n      let x1 = Math.max(rgn.xMin, x);\n      let x2 = Math.min(x + width - 1, rgn.xMax);\n\n      // Blit the off-screen buffer column into the on-screen canvas.\n      //\n      // This is *much* faster than drawing directly into the on-screen\n      // canvas with a clip rect on the column. Managed column clipping\n      // is required to prevent cell renderers from needing to set up a\n      // clip rect for handling horizontal overflow text (slow!).\n      this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);\n\n      // Increment the running X coordinate.\n      x += width;\n    }\n\n    // Dispose of the wrapped gc.\n    gc.dispose();\n\n    // Restore the final buffer gc state.\n    this._bufferGC.restore();\n  }\n\n  /**\n   * Draw the horizontal grid lines for the given paint region.\n   */\n  private _drawHorizontalGridLines(rgn: Private.PaintRegion, color: string | undefined): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the X bounds for the horizontal lines.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n    let x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);\n\n    // Begin the path for the grid lines.\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.rowSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastRow && ph > bh) {\n      if (rgn.row + n === this._rowSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the horizontal grid lines.\n    for (let y = rgn.y, j = 0; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Compute the Y position of the line.\n      let pos = y + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.yMin && pos <= rgn.yMax) {\n        this._canvasGC.moveTo(x1, pos + 0.5);\n        this._canvasGC.lineTo(x2, pos + 0.5);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the vertical grid lines for the given paint region.\n   */\n  private _drawVerticalGridLines(rgn: Private.PaintRegion, color: string | undefined): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the Y bounds for the vertical lines.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);\n\n    // Begin the path for the grid lines\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.columnSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastColumn && pw > bw) {\n      if (rgn.column + n === this._columnSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the vertical grid lines.\n    for (let x = rgn.x, i = 0; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Compute the X position of the line.\n      let pos = x + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.xMin && pos <= rgn.xMax) {\n        this._canvasGC.moveTo(pos + 0.5, y1);\n        this._canvasGC.lineTo(pos + 0.5, y2);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the body selections for the data grid.\n   */\n  private _drawBodySelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections.\n    if (!model || model.isEmpty) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.selectionFillColor;\n    let stroke = this._style.selectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the scroll geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Get the first visible cell of the grid.\n    let r1 = this._rowSections.indexOf(sy);\n    let c1 = this._columnSections.indexOf(sx);\n\n    // Bail early if there are no visible cells.\n    if (r1 < 0 || c1 < 0) {\n      return;\n    }\n\n    // Fetch the extra geometry.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Get the last visible cell of the grid.\n    let r2 = this._rowSections.indexOf(sy + ph);\n    let c2 = this._columnSections.indexOf(sx + pw);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Clamp the last cell if the void space is visible.\n    r2 = r2 < 0 ? maxRow : r2;\n    c2 = c2 < 0 ? maxColumn : c2;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Iterate over the selections.\n    let it = model.selections();\n    let s: SelectionModel.Selection | undefined;\n    while ((s = it.next()) !== undefined) {\n      // Skip the section if it's not visible.\n      if (s.r1 < r1 && s.r2 < r1) {\n        continue;\n      }\n      if (s.r1 > r2 && s.r2 > r2) {\n        continue\n      }\n      if (s.c1 < c1 && s.c2 < c1) {\n        continue;\n      }\n      if (s.c1 > c2 && s.c2 > c2) {\n        continue\n      }\n\n      // Clamp the cell to the model bounds.\n      let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n      let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n      let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n      let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n      // Swap index order if needed.\n      let tmp: number;\n      if (sr1 > sr2) {\n        tmp = sr1;\n        sr1 = sr2;\n        sr2 = tmp;\n      }\n      if (sc1 > sc2) {\n        tmp = sc1;\n        sc1 = sc2;\n        sc2 = tmp;\n      }\n\n      // Convert to pixel coordinates.\n      let x1 = this._columnSections.offsetOf(sc1) - sx + hw;\n      let y1 = this._rowSections.offsetOf(sr1) - sy + hh;\n      let x2 = this._columnSections.extentOf(sc2) - sx + hw;\n      let y2 = this._rowSections.extentOf(sr2) - sy + hh;\n\n      // Adjust the trailing X coordinate for column stretch.\n      if (this._stretchLastColumn && pw > bw && sc2 === maxColumn) {\n        x2 = hw + pw - 1;\n      }\n\n      // Adjust the trailing Y coordinate for row stretch.\n      if (this._stretchLastRow && ph > bh && sr2 === maxRow) {\n        y2 = hh + ph - 1;\n      }\n\n      // Clamp the bounds to just outside of the clipping rect.\n      x1 = Math.max(hw - 1, x1);\n      y1 = Math.max(hh - 1, y1);\n      x2 = Math.min(hw + pw + 1, x2);\n      y2 = Math.min(hh + ph + 1, y2);\n\n      // Skip zero sized ranges.\n      if (x2 < x1 || y2 < y1) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Stroke the rect if needed.\n      if (stroke) {\n        gc.strokeRect(x1 - .5, y1 - .5, x2 - x1 + 1, y2 - y1 + 1);\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the row header selections for the data grid.\n   */\n  private _drawRowHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire column.\n    if (!model || model.isEmpty || model.selectionMode == 'column') {\n      return;\n    }\n\n    // Bail early if the row headers are not visible.\n    if (this.headerWidth === 0 || this.pageHeight === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sy = this._scrollY;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let rs = this._rowSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(0, hh, hw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max row.\n    let maxRow = rs.count - 1;\n\n    // Fetch the visible rows.\n    let r1 = rs.indexOf(sy);\n    let r2 = rs.indexOf(sy + ph - 1);\n    r2 = r2 < 0 ? maxRow : r2;\n\n    // Iterate over the visible rows.\n    for (let j = r1; j <= r2; ++j) {\n      // Skip rows which aren't selected.\n      if (!model.isRowSelected(j)) {\n        continue;\n      }\n\n      // Get the dimensions of the row.\n      let y = rs.offsetOf(j) - sy + hh;\n      let h = rs.sizeOf(j);\n\n      // Adjust the height for row stretch.\n      if (this._stretchLastRow && ph > bh && j === maxRow) {\n        h = hh + ph - y;\n      }\n\n      // Skip zero sized rows.\n      if (h === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(0, y, hw, h);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(hw - .5, y - 1);\n        gc.lineTo(hw - .5, y + h);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the column header selections for the data grid.\n   */\n  private _drawColumnHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire row\n    if (!model || model.isEmpty || model.selectionMode == 'row') {\n      return;\n    }\n\n    // Bail early if the column headers are not visible.\n    if (this.headerHeight === 0 || this.pageWidth === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sx = this._scrollX;\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let cs = this._columnSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(hw, 0, pw, hh);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max column.\n    let maxCol = cs.count - 1;\n\n    // Fetch the visible columns.\n    let c1 = cs.indexOf(sx);\n    let c2 = cs.indexOf(sx + pw - 1);\n    c2 = c2 < 0 ? maxCol : c2;\n\n    // Iterate over the visible columns.\n    for (let i = c1; i <= c2; ++i) {\n      // Skip columns which aren't selected.\n      if (!model.isColumnSelected(i)) {\n        continue;\n      }\n\n      // Get the dimensions of the column.\n      let x = cs.offsetOf(i) - sx + hw;\n      let w = cs.sizeOf(i);\n\n      // Adjust the width for column stretch.\n      if (this._stretchLastColumn && pw > bw && i === maxCol) {\n        w = hw + pw - x;\n      }\n\n      // Skip zero sized columns.\n      if (w === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x, 0, w, hh);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(x - 1, hh - .5);\n        gc.lineTo(x + w, hh - .5);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay cursor for the data grid.\n   */\n  private _drawCursor(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there is no cursor.\n    if (!model || model.isEmpty || model.selectionMode !== 'cell') {\n      return;\n    }\n\n    // Extract the style information.\n    let fill = this._style.cursorFillColor;\n    let stroke = this._style.cursorBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the cursor location.\n    let row = model.cursorRow;\n    let column = model.cursorColumn;\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Bail early if the cursor is out of bounds.\n    if (row < 0 || row > maxRow) {\n      return;\n    }\n    if (column < 0 || column > maxColumn) {\n      return;\n    }\n\n    // Fetch geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Get the cursor bounds in viewport coordinates.\n    let x1 = this._columnSections.offsetOf(column) - sx + hw;\n    let x2 = this._columnSections.extentOf(column) - sx + hw;\n    let y1 = this._rowSections.offsetOf(row) - sy + hh;\n    let y2 = this._rowSections.extentOf(row) - sy + hh;\n\n    // Adjust the trailing X coordinate for column stretch.\n    if (this._stretchLastColumn && pw > bw && column === maxColumn) {\n      x2 = vw - 1;\n    }\n\n    // Adjust the trailing Y coordinate for row stretch.\n    if (this._stretchLastRow && ph > bh && row === maxRow) {\n      y2 = vh - 1;\n    }\n\n    // Skip zero sized cursors.\n    if (x2 < x1 || y2 < y1) {\n      return;\n    }\n\n    // Bail early if the cursor is off the screen.\n    if ((x1 - 1) >= vw || (y1 - 1) >= vh || (x2 + 1) < hw || (y2 + 1) < hh) {\n      return;\n    }\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Clear any existing overlay content.\n    gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n\n    // Fill the cursor rect if needed.\n    if (fill) {\n      // Set up the fill style.\n      gc.fillStyle = fill;\n\n      // Fill the cursor rect.\n      gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1)\n    }\n\n    // Stroke the cursor border if needed.\n    if (stroke) {\n      // Set up the stroke style.\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 2;\n\n      // Stroke the cursor rect.\n      gc.strokeRect(x1, y1, x2 - x1, y2 - y1);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay shadows for the data grid.\n   */\n  private _drawShadows(): void {\n    // Fetch the scroll shadow from the style.\n    let shadow = this._style.scrollShadow;\n\n    // Bail early if there is no shadow to draw.\n    if (!shadow) {\n      return;\n    }\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch maximum scroll position.\n    let sxMax = this.maxScrollX;\n    let syMax = this.maxScrollY;\n\n    // Fetch the header width and height.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the page width and height.\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Fetch the viewport width and height.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Fetch the body width and height.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n\n    // Adjust the body size for row and column stretch.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Fetch the gc object.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Draw the column header shadow if needed.\n    if (sy > 0) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = hh;\n      let x1 = 0;\n      let y1 = y0 + shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = hh;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row header shadow if needed.\n    if (sx > 0) {\n      // Set up the gradient coordinates.\n      let x0 = hw;\n      let y0 = 0;\n      let x1 = x0 + shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = hw;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the column footer shadow if needed.\n    if (sy < syMax) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = vh;\n      let x1 = 0;\n      let y1 = vh - shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = vh - shadow.size;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row footer shadow if needed.\n    if (sx < sxMax) {\n      // Set up the gradient coordinates.\n      let x0 = vw;\n      let y0 = 0;\n      let x1 = vw - shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = vw - shadow.size;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  private _viewport: Widget;\n  private _vScrollBar: ScrollBar;\n  private _hScrollBar: ScrollBar;\n  private _scrollCorner: Widget;\n\n  private _scrollX = 0;\n  private _scrollY = 0;\n  private _viewportWidth = 0;\n  private _viewportHeight = 0;\n\n  private _mousedown = false;\n  private _keyHandler: DataGrid.IKeyHandler | null = null;\n  private _mouseHandler: DataGrid.IMouseHandler | null = null;\n\n  private _vScrollBarMinWidth = 0;\n  private _hScrollBarMinHeight = 0;\n  private _dpiRatio = Math.ceil(window.devicePixelRatio);\n\n  private _canvas: HTMLCanvasElement;\n  private _buffer: HTMLCanvasElement;\n  private _overlay: HTMLCanvasElement;\n  private _canvasGC: CanvasRenderingContext2D;\n  private _bufferGC: CanvasRenderingContext2D;\n  private _overlayGC: CanvasRenderingContext2D;\n\n  private _rowSections: SectionList;\n  private _columnSections: SectionList;\n  private _rowHeaderSections: SectionList;\n  private _columnHeaderSections: SectionList;\n\n  private _dataModel: DataModel | null = null;\n  private _selectionModel: SelectionModel | null = null;\n\n  private _stretchLastRow: boolean;\n  private _stretchLastColumn: boolean;\n\n  private _style: DataGrid.Style;\n  private _cellRenderers: RendererMap;\n  private _copyConfig: DataGrid.CopyConfig;\n  private _headerVisibility: DataGrid.HeaderVisibility;\n  private _editorController: ICellEditorController | null;\n  private _editingEnabled: boolean = false;\n}\n\n\n/**\n * The namespace for the `DataGrid` class statics.\n */\nexport\nnamespace DataGrid {\n  /**\n   * An object which defines the style for a data grid.\n   *\n   * #### Notes\n   * All style colors support the full CSS color syntax.\n   */\n  export\n  type Style = {\n    /**\n     * The void color for the data grid.\n     *\n     * This is the base fill color for the entire data grid.\n     */\n    readonly voidColor?: string;\n\n    /**\n     * The background color for the body cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly backgroundColor?: string;\n\n    /**\n     * A function which returns the background color for a row.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid rows.\n     */\n    readonly rowBackgroundColor?: (index: number) => string;\n\n    /**\n     * A function which returns the background color for a column.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid columns.\n     */\n    readonly columnBackgroundColor?: (index: number) => string;\n\n    /**\n     * The color for the grid lines of the body cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly gridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly verticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly horizontalGridLineColor?: string;\n\n    /**\n     * The background color for the header cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly headerBackgroundColor?: string;\n\n    /**\n     * The color for the grid lines of the header cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly headerGridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerVerticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerHorizontalGridLineColor?: string;\n\n    /**\n     * The fill color for a selection.\n     */\n    readonly selectionFillColor?: string;\n\n    /**\n     * The border color for a selection.\n     */\n    readonly selectionBorderColor?: string;\n\n    /**\n     * The fill color for the cursor.\n     */\n    readonly cursorFillColor?: string;\n\n    /**\n     * The border color for the cursor.\n     */\n    readonly cursorBorderColor?: string;\n\n    /**\n     * The fill color for a header selection.\n     */\n    readonly headerSelectionFillColor?: string;\n\n    /**\n     * The border color for a header selection.\n     */\n    readonly headerSelectionBorderColor?: string;\n\n    /**\n     * The drop shadow effect when the grid is scrolled.\n     */\n    readonly scrollShadow?: {\n      /**\n       * The size of the shadow, in pixels.\n       */\n      readonly size: number;\n\n      /**\n       * The first color stop for the shadow.\n       */\n      readonly color1: string;\n\n      /**\n       * The second color stop for the shadow.\n       */\n      readonly color2: string;\n\n      /**\n       * The third color stop for the shadow.\n       */\n      readonly color3: string;\n    };\n  };\n\n  /**\n   * An object which defines the default sizes for a data grid.\n   */\n  export\n  type DefaultSizes = {\n    /**\n     * The default height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The default width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The default width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The default height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * An object which defines the minimum sizes for a data grid.\n   */\n  export\n  type MinimumSizes = {\n    /**\n     * The minimum height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The minimum width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The minimum width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The minimum height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * A type alias for the supported header visibility modes.\n   */\n  export\n  type HeaderVisibility = 'all' | 'row' | 'column' | 'none';\n\n  /**\n   * A type alias for the arguments to a copy format function.\n   */\n  export\n  type CopyFormatArgs = {\n    /**\n     * The cell region for the value.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the value.\n     */\n    row: number;\n\n    /**\n     * The column index of the value.\n     */\n    column: number;\n\n    /**\n     * The value for the cell.\n     */\n    value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a copy format function.\n   */\n  export\n  type CopyFormatFunc = (args: CopyFormatArgs) => string;\n\n  /**\n   * A type alias for the data grid copy config.\n   */\n  export\n  type CopyConfig = {\n    /**\n     * The separator to use between values.\n     */\n    readonly separator: string;\n\n    /**\n     * The headers to included in the copied output.\n     */\n    readonly headers: 'none' | 'row' | 'column' | 'all';\n\n    /**\n     * The function for formatting the data values.\n     */\n    readonly format: CopyFormatFunc;\n\n    /**\n     * The cell count threshold for a copy to be considered \"large\".\n     */\n    readonly warningThreshold: number;\n  };\n\n  /**\n   * An options object for initializing a data grid.\n   */\n  export\n  interface IOptions {\n    /**\n     * The style for the data grid.\n     *\n     * The default is `DataGrid.defaultStyle`.\n     */\n    style?: Style;\n\n    /**\n     * The default sizes for the data grid.\n     *\n     * The default is `DataGrid.defaultSizes`.\n     */\n    defaultSizes?: DefaultSizes;\n\n    /**\n     * The minimum sizes for the data grid.\n     *\n     * The default is `DataGrid.minimumSizes`.\n     */\n    minimumSizes?: MinimumSizes;\n\n    /**\n     * The header visibility for the data grid.\n     *\n     * The default is `'all'`.\n     */\n    headerVisibility?: HeaderVisibility;\n\n    /**\n     * The cell renderer map for the data grid.\n     *\n     * The default is an empty renderer map.\n     */\n    cellRenderers?: RendererMap;\n\n    /**\n     * The default cell renderer for the data grid.\n     *\n     * The default is a new `TextRenderer`.\n     */\n    defaultRenderer?: CellRenderer;\n\n    /**\n     * The copy configuration data for the grid.\n     *\n     * The default is `DataGrid.defaultCopyConfig`.\n     */\n    copyConfig?: CopyConfig;\n\n    /**\n     * Whether to stretch the last row of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastRow?: boolean;\n\n    /**\n     * Whether to stretch the last column of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastColumn?: boolean;\n  }\n\n  /**\n   * An object which handles keydown events for the data grid.\n   */\n  export\n  interface IKeyHandler extends IDisposable {\n    /**\n     * Handle the key down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keydown event of interest.\n     *\n     * #### Notes\n     * This will not be called if the mouse button is pressed.\n     */\n    onKeyDown(grid: DataGrid, event: KeyboardEvent): void;\n  }\n\n  /**\n   * An object which handles mouse events for the data grid.\n   */\n  export\n  interface IMouseHandler extends IDisposable {\n    /**\n     * Release any resources acquired during a mouse press.\n     *\n     * #### Notes\n     * This method is called when the mouse should be released\n     * independent of a mouseup event, such as an early detach.\n     */\n    release(): void;\n\n    /**\n     * Handle the mouse hover event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseHover(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse leave event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseLeave(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse down event of interest.\n     */\n    onMouseDown(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse move event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse move event of interest.\n     */\n    onMouseMove(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse up event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    onMouseUp(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse double click event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse double click event of interest.\n     */\n    onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the context menu event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The context menu event of interest.\n     */\n    onContextMenu(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the wheel event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The wheel event of interest.\n     */\n    onWheel(grid: DataGrid, event: WheelEvent): void;\n  }\n\n  /**\n   * An object which holds the result of a grid hit test.\n   */\n  export\n  type HitTestResult = {\n    /**\n     * The region of the data grid that was hit.\n     */\n    readonly region: DataModel.CellRegion | 'void';\n\n    /**\n     * The row index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly column: number;\n\n    /**\n     * The X coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly x: number;\n\n    /**\n     * The Y coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly y: number;\n\n    /**\n     * The width of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly width: number;\n\n    /**\n     * The height of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly height: number;\n  };\n\n  /**\n   * A generic format function for the copy handler.\n   *\n   * @param args - The format args for the function.\n   *\n   * @returns The string representation of the value.\n   *\n   * #### Notes\n   * This function uses `String()` to coerce a value to a string.\n   */\n  export\n  function copyFormatGeneric(args: CopyFormatArgs): string {\n    if (args.value === null || args.value === undefined) {\n      return '';\n    }\n    return String(args.value);\n  }\n\n  /**\n   * The default theme for a data grid.\n   */\n  export\n  const defaultStyle: Style = {\n    voidColor: '#F3F3F3',\n    backgroundColor: '#FFFFFF',\n    gridLineColor: 'rgba(20, 20, 20, 0.15)',\n    headerBackgroundColor: '#F3F3F3',\n    headerGridLineColor: 'rgba(20, 20, 20, 0.25)',\n    selectionFillColor: 'rgba(49, 119, 229, 0.2)',\n    selectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    cursorBorderColor: 'rgba(0, 107, 247, 1.0)',\n    headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',\n    headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    scrollShadow: {\n      size: 10,\n      color1: 'rgba(0, 0, 0, 0.20)',\n      color2: 'rgba(0, 0, 0, 0.05)',\n      color3: 'rgba(0, 0, 0, 0.00)' }\n  };\n\n  /**\n   * The default sizes for a data grid.\n   */\n  export\n  const defaultSizes: DefaultSizes = {\n    rowHeight: 20,\n    columnWidth: 64,\n    rowHeaderWidth: 64,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default minimum sizes for a data grid.\n   */\n  export\n  const minimumSizes: MinimumSizes = {\n    rowHeight: 20,\n    columnWidth: 10,\n    rowHeaderWidth: 10,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default copy config for a data grid.\n   */\n  export\n  const defaultCopyConfig: CopyConfig = {\n    separator: '\\t',\n    format: copyFormatGeneric,\n    headers: 'none',\n    warningThreshold: 1e6\n  };\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A singleton `scroll-request` conflatable message.\n   */\n  export\n  const ScrollRequest = new ConflatableMessage('scroll-request');\n\n  /**\n   * A singleton `section-resize-request` conflatable message.\n   */\n  export\n  const SectionResizeRequest = new ConflatableMessage('section-resize-request');\n\n  /**\n   * A singleton `overlay-paint-request` conflatable message.\n   */\n  export\n  const OverlayPaintRequest = new ConflatableMessage('overlay-paint-request');\n\n  /**\n   * Create a new zero-sized canvas element.\n   */\n  export\n  function createCanvas(): HTMLCanvasElement {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas;\n  }\n\n  /**\n   * An object which represents a region to be painted.\n   */\n  export\n  type PaintRegion = {\n    /**\n     * The min X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMin: number;\n\n    /**\n     * The min Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMin: number;\n\n    /**\n     * The max X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMax: number;\n\n    /**\n     * The max Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMax: number;\n\n    /**\n     * The X coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    x: number;\n\n    /**\n     * The Y coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    y: number;\n\n    /**\n     * The total width of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    width: number;\n\n    /**\n     * The total height of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    height: number;\n\n    /**\n     * The cell region being painted.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the first cell in the region.\n     */\n    row: number;\n\n    /**\n     * The column index of the first cell in the region.\n     */\n    column: number;\n\n    /**\n     * The row sizes for the rows in the region.\n     */\n    rowSizes: number[];\n\n    /**\n     * The column sizes for the columns in the region.\n     */\n    columnSizes: number[];\n  };\n\n  /**\n   * A conflatable message which merges dirty paint regions.\n   */\n  export\n  class PaintRequest extends ConflatableMessage {\n    /**\n     * Construct a new paint request messages.\n     *\n     * @param region - The cell region for the paint.\n     *\n     * @param r1 - The top-left row of the dirty region.\n     *\n     * @param c1 - The top-left column of the dirty region.\n     *\n     * @param r2 - The bottom-right row of the dirty region.\n     *\n     * @param c2 - The bottom-right column of the dirty region.\n     */\n    constructor(region: DataModel.CellRegion | 'all', r1: number, c1: number, r2: number, c2: number) {\n      super('paint-request');\n      this._region = region;\n      this._r1 = r1;\n      this._c1 = c1;\n      this._r2 = r2;\n      this._c2 = c2;\n    }\n\n    /**\n     * The cell region for the paint.\n     */\n    get region(): DataModel.CellRegion | 'all' {\n      return this._region;\n    }\n\n    /**\n     * The top-left row of the dirty region.\n     */\n    get r1(): number {\n      return this._r1;\n    }\n\n    /**\n     * The top-left column of the dirty region.\n     */\n    get c1(): number {\n      return this._c1;\n    }\n\n    /**\n     * The bottom-right row of the dirty region.\n     */\n    get r2(): number {\n      return this._r2;\n    }\n\n    /**\n     * The bottom-right column of the dirty region.\n     */\n    get c2(): number {\n      return this._c2;\n    }\n\n    /**\n     * Conflate this message with another paint request.\n     */\n    conflate(other: PaintRequest): boolean {\n      // Bail early if the request is already painting everything.\n      if (this._region === 'all') {\n        return true;\n      }\n\n      // Any region can conflate with the `'all'` region.\n      if (other._region === 'all') {\n        this._region = 'all';\n        return true;\n      }\n\n      // Otherwise, do not conflate with a different region.\n      if (this._region !== other._region) {\n        return false;\n      }\n\n      // Conflate the region to the total boundary.\n      this._r1 = Math.min(this._r1, other._r1);\n      this._c1 = Math.min(this._c1, other._c1);\n      this._r2 = Math.max(this._r2, other._r2);\n      this._c2 = Math.max(this._c2, other._c2);\n      return true;\n    }\n\n    private _region: DataModel.CellRegion | 'all';\n    private _r1: number;\n    private _c1: number;\n    private _r2: number;\n    private _c2: number;\n  }\n\n  /**\n   * A conflatable message for resizing rows.\n   */\n  export\n  class RowResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new row resize request.\n     *\n     * @param region - The row region which holds the section.\n     *\n     * @param index - The index of row in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.RowRegion, index: number, size: number) {\n      super('row-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The row region which holds the section.\n     */\n    get region(): DataModel.RowRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the row in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another row resize request.\n     */\n    conflate(other: RowResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.RowRegion;\n    private _index: number;\n    private _size: number;\n  }\n\n  /**\n   * A conflatable message for resizing columns.\n   */\n  export\n  class ColumnResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new column resize request.\n     *\n     * @param region - The column region which holds the section.\n     *\n     * @param index - The index of column in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.ColumnRegion, index: number, size: number) {\n      super('column-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The column region which holds the section.\n     */\n    get region(): DataModel.ColumnRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the column in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another column resize request.\n     */\n    conflate(other: ColumnResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.ColumnRegion;\n    private _index: number;\n    private _size: number;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ReadonlyJSONObject\n} from '@lumino/coreutils';\n\nimport {\n  DataModel\n} from './datamodel';\n\n\n/**\n * A data model implementation for in-memory JSON data.\n */\nexport\nclass JSONModel extends DataModel {\n  /**\n   * Create a data model with static JSON data.\n   *\n   * @param options - The options for initializing the data model.\n   */\n  constructor(options: JSONModel.IOptions) {\n    super();\n    let split = Private.splitFields(options.schema);\n    this._data = options.data;\n    this._bodyFields = split.bodyFields;\n    this._headerFields = split.headerFields;\n    this._missingValues = Private.createMissingMap(options.schema);\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    if (region === 'body') {\n      return this._data.length;\n    }\n    return 1;  // TODO multiple column-header rows?\n  }\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    if (region === 'body') {\n      return this._bodyFields.length;\n    }\n    return this._headerFields.length;\n  }\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns - The data value for the specified cell.\n   *\n   * #### Notes\n   * A `missingValue` as defined by the schema is converted to `null`.\n   */\n  data(region: DataModel.CellRegion, row: number, column: number): any {\n    // Set up the field and value variables.\n    let field: JSONModel.Field;\n    let value: any;\n\n    // Look up the field and value for the region.\n    switch (region) {\n    case 'body':\n      field = this._bodyFields[column];\n      value = this._data[row][field.name];\n      break;\n    case 'column-header':\n      field = this._bodyFields[column];\n      value = field.title || field.name;\n      break;\n    case 'row-header':\n      field = this._headerFields[column];\n      value = this._data[row][field.name];\n      break;\n    case 'corner-header':\n      field = this._headerFields[column];\n      value = field.title || field.name;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Test whether the value is a missing value.\n    let missing = (\n      this._missingValues !== null &&\n      typeof value === 'string' &&\n      this._missingValues[value] === true\n    );\n\n    // Return the final value.\n    return missing ? null : value;\n  }\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the cell.\n   */\n  metadata(region: DataModel.CellRegion, row: number, column: number): DataModel.Metadata {\n    if (region === 'body' || region === 'column-header') {\n      return this._bodyFields[column];\n    }\n    return this._headerFields[column];\n  }\n\n  private _data: JSONModel.DataSource;\n  private _bodyFields: JSONModel.Field[];\n  private _headerFields: JSONModel.Field[];\n  private _missingValues: Private.MissingValuesMap | null;\n}\n\n\n/**\n * The namespace for the `JSONModel` class statics.\n */\nexport\nnamespace JSONModel {\n  /**\n   * An object which describes a column of data in the model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export\n  type Field = {\n    /**\n     * The name of the column.\n     *\n     * This is used as the key to extract a value from a data record.\n     * It is also used as the column header label, unless the `title`\n     * property is provided.\n     */\n    readonly name: string;\n\n    /**\n     * The type of data held in the column.\n     */\n    readonly type?: string;\n\n    /**\n     * The format of the data in the column.\n     */\n    readonly format?: string;\n\n    /**\n     * The human readable name for the column.\n     *\n     * This is used as the label for the column header.\n     */\n    readonly title?: string;\n\n    // TODO want/need support for any these?\n    // description?: string;\n    // constraints?: IConstraints;\n    // rdfType?: string;\n  };\n\n  /**\n   * An object when specifies the schema for a data model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export\n  type Schema = {\n    /**\n     * The fields which describe the data model columns.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly fields: Field[];\n\n    /**\n     * The values to treat as \"missing\" data.\n     *\n     * Missing values are automatically converted to `null`.\n     */\n    readonly missingValues?: string[];\n\n    /**\n     * The field names which act as primary keys.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly primaryKey?: string | string[];\n\n    // TODO want/need support for this?\n    // foreignKeys?: IForeignKey[];\n  };\n\n  /**\n   * A type alias for a data source for a JSON data model.\n   *\n   * A data source is an array of JSON object records which represent\n   * the rows of the table. The keys of the records correspond to the\n   * field names of the columns.\n   */\n  export\n  type DataSource = ReadonlyArray<ReadonlyJSONObject>;\n\n  /**\n   * An options object for initializing a JSON data model.\n   */\n  export\n  interface IOptions {\n    /**\n     * The schema for the for the data model.\n     *\n     * The schema should be treated as an immutable object.\n     */\n    schema: Schema;\n\n    /**\n     * The data source for the data model.\n     *\n     * The data model takes full ownership of the data source.\n     */\n    data: DataSource;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the results of splitting schema fields.\n   */\n  export\n  type SplitFieldsResult = {\n    /**\n     * The non-primary key fields to use for the grid body.\n     */\n    bodyFields: JSONModel.Field[];\n\n    /**\n     * The primary key fields to use for the grid headers.\n     */\n    headerFields: JSONModel.Field[];\n  };\n\n  /**\n   * Split the schema fields into header and body fields.\n   */\n  export\n  function splitFields(schema: JSONModel.Schema): SplitFieldsResult {\n    // Normalize the primary keys.\n    let primaryKeys: string[];\n    if (schema.primaryKey === undefined) {\n      primaryKeys = [];\n    } else if (typeof schema.primaryKey === 'string') {\n      primaryKeys = [schema.primaryKey];\n    } else {\n      primaryKeys = schema.primaryKey;\n    }\n\n    // Separate the fields for the body and header.\n    let bodyFields: JSONModel.Field[] = [];\n    let headerFields: JSONModel.Field[] = [];\n    for (let field of schema.fields) {\n      if (primaryKeys.indexOf(field.name) === -1) {\n        bodyFields.push(field);\n      } else {\n        headerFields.push(field);\n      }\n    }\n\n    // Return the separated fields.\n    return { bodyFields, headerFields };\n  }\n\n  /**\n   * A type alias for a missing value map.\n   */\n  export\n  type MissingValuesMap = { [key: string]: boolean };\n\n  /**\n   * Create a missing values map for a schema.\n   *\n   * This returns `null` if there are no missing values.\n   */\n  export\n  function createMissingMap(schema: JSONModel.Schema): MissingValuesMap | null {\n    // Bail early if there are no missing values.\n    if (!schema.missingValues || schema.missingValues.length === 0) {\n      return null;\n    }\n\n    // Collect the missing values into a map.\n    let result: MissingValuesMap = Object.create(null);\n    for (let value of schema.missingValues) {\n      result[value] = true;\n    }\n\n    // Return the populated map.\n    return result;\n  }\n}\n"]}